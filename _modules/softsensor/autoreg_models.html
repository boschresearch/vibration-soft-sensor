

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>softsensor.autoreg_models &mdash; Template-Python</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=03e43079" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../_static/jupyter-sphinx.css" />
      <link rel="stylesheet" type="text/css" href="../../_static/thebelab.css" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/custom.css?v=f65bdc5e" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/fix-rtd-property.css?v=3d3ddd9d" />

  
      <script src="../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../_static/documentation_options.js?v=34f4cfc2"></script>
      <script src="../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script src="../../_static/thebelab-helper.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
      <script src="https://cdn.jsdelivr.net/npm/@jupyter-widgets/html-manager@^1.0.1/dist/embed-amd.js"></script>
      <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            softsensor
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">About</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../README.html">vibration-soft-sensor   <!-- omit in toc --></a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Tutorials</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../tutorials.html">Tutorials</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../reference.html">Data Preprocessing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../reference.html#linear-methods">Linear Methods</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../reference.html#neural-networks">Neural Networks</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../reference.html#training-methods">Training Methods</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../reference.html#postprocessing">Postprocessing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../reference.html#frequency-methods">Frequency Methods</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">softsensor</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">softsensor.autoreg_models</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for softsensor.autoreg_models</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Created on Fri Mar 11 17:26:16 2022</span>

<span class="sd">@author: WET2RNG</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">math</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">inspect</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">enum</span><span class="w"> </span><span class="kn">import</span> <span class="n">Enum</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="c1">#from import tqdm</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">torch</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">torch.nn</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">nn</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">torch.nn.functional</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">F</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">torch.autograd</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span><span class="n">grad</span><span class="p">,</span> <span class="n">Variable</span><span class="p">)</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">torchinfo</span><span class="w"> </span><span class="kn">import</span> <span class="n">summary</span>
<span class="c1"># from captum.attr import LRP</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy.stats.qmc</span><span class="w"> </span><span class="kn">import</span> <span class="n">LatinHypercube</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">softsensor.losses</span><span class="w"> </span><span class="kn">import</span> <span class="n">GaussianNLLLoss</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">softsensor.model</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span><span class="n">CNN</span><span class="p">,</span> <span class="n">Feed_ForwardNN</span><span class="p">,</span> <span class="n">Freq_Att_CNN</span><span class="p">,</span>
                              <span class="n">_filter_parameters</span><span class="p">)</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">softsensor.train_model</span><span class="w"> </span><span class="kn">import</span> <span class="n">train_model</span>



<span class="k">class</span><span class="w"> </span><span class="nc">SensitivityMethods</span><span class="p">(</span><span class="n">Enum</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Enumeration class, representing all currently available sensitivity methods.</span>
<span class="sd">    Applicable methods are: &#39;gradient&#39; and &#39;perturbation&#39;.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">GRADIENT</span> <span class="o">=</span> <span class="s1">&#39;gradient&#39;</span>
    <span class="n">SMOOTH_GRAD</span> <span class="o">=</span> <span class="s1">&#39;smooth_grad&#39;</span>
    <span class="n">INTEGRATED_GRADIENT</span> <span class="o">=</span> <span class="s1">&#39;integrated_gradient&#39;</span>
    <span class="n">PERTURBATION</span> <span class="o">=</span> <span class="s1">&#39;perturbation&#39;</span>


<span class="k">class</span><span class="w"> </span><span class="nc">_Autoregressive_Model</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Parent class for all Autoregressive models</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    input_channels : int</span>
<span class="sd">        Number of input channels</span>
<span class="sd">    pred_size : int</span>
<span class="sd">        Number of predicted values</span>
<span class="sd">    window_size : int</span>
<span class="sd">        window size of the input. Number of Datapoints in the windowed</span>
<span class="sd">        external excitation signal</span>
<span class="sd">    rnn_window : int, optional</span>
<span class="sd">        Window Size of the Recurrent Connection</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    None.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_channels</span><span class="p">,</span> <span class="n">pred_size</span><span class="p">,</span> <span class="n">window_size</span><span class="p">,</span> <span class="n">rnn_window</span><span class="p">,</span>
                 <span class="n">forecast</span><span class="p">):</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">input_channels</span> <span class="o">=</span> <span class="n">input_channels</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pred_size</span> <span class="o">=</span> <span class="n">pred_size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">window_size</span> <span class="o">=</span> <span class="n">window_size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rnn_window</span> <span class="o">=</span> <span class="n">rnn_window</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">forecast</span> <span class="o">=</span> <span class="n">forecast</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">Type</span> <span class="o">=</span> <span class="s1">&#39;AR&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Pred_Type</span> <span class="o">=</span> <span class="s1">&#39;Point&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Ensemble</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">prediction</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataloader</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="s1">&#39;cpu&#39;</span><span class="p">,</span> <span class="n">sens_params</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Prediction of a whole Time Series</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dataloader : Dataloader</span>
<span class="sd">            Dataloader to predict output</span>
<span class="sd">        device : str, optional</span>
<span class="sd">            device to compute on. The default is &#39;cpu&#39;.</span>
<span class="sd">        sens_params : dict, optional</span>
<span class="sd">            Dictionary that contains the parameters for the sensitivity analysis.</span>
<span class="sd">            Key &#39;method&#39; defines the method for sensitivity analysis: &#39;gradient&#39; or &#39;perturbation&#39;.</span>
<span class="sd">            Key &#39;comp&#39; defines whether gradients are computed for sensitivity analysis.</span>
<span class="sd">            Key &#39;plot&#39; defines whether the results of the sensitivity analysis are visualized.</span>
<span class="sd">            Key &#39;verbose&#39; defines whether the information about the sensitivity analysis is printed.</span>
<span class="sd">            Key &#39;sens_length&#39; defines the number of randomly sampled subset of timesteps for the analysis.</span>
<span class="sd">            The default is None, i.e. no sensitivity analysis is computed.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        if loss_ft=None:</span>
<span class="sd">            torch.Tensor</span>
<span class="sd">                Torch Tensor of same langth as input</span>
<span class="sd">        if loss_ft=torch loss function:</span>
<span class="sd">            (torch.Tensor, loss)</span>
<span class="sd">                tuple of Torch Tensor of same langth as input and loss</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_predict_ARNN</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataloader</span><span class="p">,</span> <span class="n">device</span><span class="p">,</span> <span class="n">sens_params</span><span class="p">)</span>


<div class="viewcode-block" id="ARNN">
<a class="viewcode-back" href="../../autoreg_models.html#softsensor.autoreg_models.ARNN">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">ARNN</span><span class="p">(</span><span class="n">_Autoregressive_Model</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Autoregressive Neural Network with linear layers</span>
<span class="sd">        </span>
<span class="sd">    .. math:: window_size = rnn_window = tau</span>
<span class="sd">    .. math:: forecast = 1</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    input_channels : int</span>
<span class="sd">        Number of input channels</span>
<span class="sd">    pred_size : int</span>
<span class="sd">        Number of predicted values</span>
<span class="sd">    window_size : int</span>
<span class="sd">        Size of the sliding window applied to the time series</span>
<span class="sd">    rnn_window : int</span>
<span class="sd">        Window Size of the Recurrent Connection before the DNN.</span>
<span class="sd">    hidden_size : list of int or None, optional</span>
<span class="sd">        List gives the size of hidden units. The default is None.</span>
<span class="sd">    activation : str, optional</span>
<span class="sd">        Activation function to activate the feature space.</span>
<span class="sd">        The default is &#39;relu&#39;.</span>
<span class="sd">    bias : bool, optional</span>
<span class="sd">        If True, bias weights are used. The default is True.</span>
<span class="sd">    dropout : float [0,1], optional</span>
<span class="sd">        Adds dropout Layers after each Linear Layer. The default is None.</span>
<span class="sd">    forecast : int, optional</span>
<span class="sd">        Size of the forecast. The default is 1</span>
<span class="sd">    concrete_dropout : bool, optional</span>
<span class="sd">        Whether to use normal or concrete dropout Layers if dropout is not None. The default is False</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    None.</span>
<span class="sd">    </span>
<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import softsensor.autoreg_models</span>
<span class="sd">    &gt;&gt;&gt; import torch</span>
<span class="sd">    &gt;&gt;&gt; m = softsensor.autoreg_models.ARNN(2, 1, 10, 10, [16, 8])</span>
<span class="sd">    &gt;&gt;&gt; input = torch.randn(32, 2, 10)</span>
<span class="sd">    &gt;&gt;&gt; rec_input = torch.randn(32, 1, 10)</span>
<span class="sd">    &gt;&gt;&gt; output = m(input, rec_input)</span>
<span class="sd">    &gt;&gt;&gt; print(output.shape)</span>
<span class="sd">    torch.Size([32, 1, 1])</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; import softsensor.meas_handling as ms</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; import pandas as pd</span>
<span class="sd">    &gt;&gt;&gt; t = np.linspace(0, 1.0, 101)</span>
<span class="sd">    &gt;&gt;&gt; d = {&#39;inp1&#39;: np.random.randn(101),</span>
<span class="sd">             &#39;inp2&#39;: np.random.randn(101),</span>
<span class="sd">             &#39;out&#39;: np.random.randn(101)}</span>
<span class="sd">    &gt;&gt;&gt; handler = ms.Meas_handling([pd.DataFrame(d, index=t)], [&#39;train&#39;],</span>
<span class="sd">                                   [&#39;inp1&#39;, &#39;inp2&#39;], [&#39;out&#39;], fs=100)</span>
<span class="sd">    &gt;&gt;&gt; loader = handler.give_list(window_size=10, keyword=&#39;training&#39;,</span>
<span class="sd">                                   rnn_window=10, batch_size=1)</span>
<span class="sd">    &gt;&gt;&gt; pred = m.prediction(loader[0])</span>
<span class="sd">    &gt;&gt;&gt; print(pred.shape)</span>
<span class="sd">    torch.Size([1, 101])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_channels</span><span class="p">,</span> <span class="n">pred_size</span><span class="p">,</span> <span class="n">window_size</span><span class="p">,</span> <span class="n">rnn_window</span><span class="p">,</span>
                 <span class="n">hidden_size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">activation</span><span class="o">=</span><span class="s1">&#39;relu&#39;</span><span class="p">,</span> <span class="n">bias</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">dropout</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">forecast</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">concrete_dropout</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">bn</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>

        <span class="n">_Autoregressive_Model</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_channels</span><span class="p">,</span> <span class="n">pred_size</span><span class="p">,</span>
                                      <span class="n">window_size</span><span class="p">,</span> <span class="n">rnn_window</span><span class="p">,</span> <span class="n">forecast</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">params</span> <span class="o">=</span> <span class="n">_filter_parameters</span><span class="p">(</span><span class="nb">locals</span><span class="p">()</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">activation</span> <span class="o">=</span> <span class="n">activation</span>

        <span class="n">flatten_size</span> <span class="o">=</span> <span class="n">window_size</span><span class="o">*</span><span class="n">input_channels</span><span class="o">+</span><span class="n">rnn_window</span><span class="o">*</span><span class="n">pred_size</span>

        <span class="c1"># Define Linear Network</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">DNN</span> <span class="o">=</span> <span class="n">Feed_ForwardNN</span><span class="p">(</span><span class="n">flatten_size</span><span class="p">,</span> <span class="n">pred_size</span><span class="o">*</span><span class="n">forecast</span><span class="p">,</span>
                                <span class="n">hidden_size</span><span class="p">,</span> <span class="n">activation</span><span class="o">=</span><span class="n">activation</span><span class="p">,</span>
                                <span class="n">bias</span><span class="o">=</span><span class="n">bias</span><span class="p">,</span> <span class="n">dropout</span><span class="o">=</span><span class="n">dropout</span><span class="p">,</span> <span class="n">concrete_dropout</span><span class="o">=</span><span class="n">concrete_dropout</span><span class="p">,</span>
                                <span class="n">bn</span><span class="o">=</span><span class="n">bn</span><span class="p">)</span>

<div class="viewcode-block" id="ARNN.forward">
<a class="viewcode-back" href="../../autoreg_models.html#softsensor.autoreg_models.ARNN.forward">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inp</span><span class="p">,</span> <span class="n">x_rec</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Forward function to propagate through the network</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        inp : torch.tensor dtype=torch.float</span>
<span class="sd">            Input tensor for forward propagation,</span>
<span class="sd">            shape=[batch size, external channels, window_size]</span>
<span class="sd">        x_rec : torch.tensor, dtype=torch.float</span>
<span class="sd">            Recurrent Input for forward Propagation.</span>
<span class="sd">            shape=[batch size, pred_size, rnn_window]</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        output: torch.tensor dtype=torch.float()</span>
<span class="sd">            shape=[batch size, pred_size, forecast]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">inp</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">inp</span><span class="p">,</span> <span class="n">start_dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">x_rec</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">x_rec</span><span class="p">,</span> <span class="n">start_dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">pred</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">DNN</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">((</span><span class="n">inp</span><span class="p">,</span> <span class="n">x_rec</span><span class="p">),</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">pred</span> <span class="o">=</span> <span class="n">pred</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pred_size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">forecast</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">pred</span></div>


<div class="viewcode-block" id="ARNN.forward_sens">
<a class="viewcode-back" href="../../autoreg_models.html#softsensor.autoreg_models.ARNN.forward_sens">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">forward_sens</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inp</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Forward function to propagate through the network, but only with one input tensor</span>
<span class="sd">        that is already concatenated to allow for gradient-based sensitivity analysis</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        inp : torch.tensor dtype=torch.float</span>
<span class="sd">            Input tensor for forward propagation that is already concatenated,</span>
<span class="sd">            shape=[batch size, external channels*window_size + pred_size*rnn_window]</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        output: torch.tensor dtype=torch.float()</span>
<span class="sd">            shape=[batch size, pred_size, forecast]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pred</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">DNN</span><span class="p">(</span><span class="n">inp</span><span class="p">)</span>
        <span class="n">pred</span> <span class="o">=</span> <span class="n">pred</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pred_size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">forecast</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">pred</span></div>


<div class="viewcode-block" id="ARNN.get_recurrent_weights">
<a class="viewcode-back" href="../../autoreg_models.html#softsensor.autoreg_models.ARNN.get_recurrent_weights">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_recurrent_weights</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function that returns the weight that effect the Recurrent input of the</span>
<span class="sd">        Network</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        recurrent_weights : list of weight Tensors</span>
<span class="sd">            List of the Weights that effect the Recurren input of the Network.</span>
<span class="sd">            </span>
<span class="sd">        Example</span>
<span class="sd">        -------</span>
<span class="sd">        Based on the example in the introduction</span>
<span class="sd">        </span>
<span class="sd">        &gt;&gt;&gt; rec_w = m.get_recurrent_weights()</span>
<span class="sd">        &gt;&gt;&gt; print(rec_w[0].shape)</span>
<span class="sd">        torch.Size([16, 10])</span>
<span class="sd">        &gt;&gt;&gt; print(rec_w[1].shape)</span>
<span class="sd">        torch.Size([8, 16])</span>
<span class="sd">        &gt;&gt;&gt; print(rec_w[2].shape)</span>
<span class="sd">        torch.Size([1, 8])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">input_pred_slice</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">rnn_window</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">pred_size</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_get_recurrent_weights</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">DNN</span><span class="o">.</span><span class="n">named_parameters</span><span class="p">(),</span> <span class="n">input_pred_slice</span><span class="p">)</span></div>
</div>



<div class="viewcode-block" id="DensityEstimationARNN">
<a class="viewcode-back" href="../../autoreg_models.html#softsensor.autoreg_models.DensityEstimationARNN">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">DensityEstimationARNN</span><span class="p">(</span><span class="n">ARNN</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ARNN with two outputs to predict mean and variance (aleatoric uncertainty)</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    input_channels : int</span>
<span class="sd">        Number of input channels</span>
<span class="sd">    pred_size : int</span>
<span class="sd">        Number of predicted values</span>
<span class="sd">    window_size : int</span>
<span class="sd">        Size of the sliding window applied to the time series</span>
<span class="sd">    rnn_window : int</span>
<span class="sd">        Window Size of the Recurrent Connection before the DNN.</span>
<span class="sd">    hidden_size : list of int or None, optional</span>
<span class="sd">        List gives the size of hidden units. The default is None.</span>
<span class="sd">    activation : str, optional</span>
<span class="sd">        Activation function to activate the feature space.</span>
<span class="sd">        The default is &#39;relu&#39;.</span>
<span class="sd">    bias : bool, optional</span>
<span class="sd">        If True, bias weights are used. The default is True.</span>
<span class="sd">    dropout : float [0,1], optional</span>
<span class="sd">        Adds dropout Layers after each Linear Layer. The default is None</span>
<span class="sd">    forecast : int, optional</span>
<span class="sd">        Size of the forecast. The default is 1</span>
<span class="sd">    concrete_dropout : bool, optional</span>
<span class="sd">        Whether to use normal or concrete dropout Layers if dropout is not None. The default is False</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    None.</span>
<span class="sd">    </span>
<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import softsensor.autoreg_models</span>
<span class="sd">    &gt;&gt;&gt; import torch</span>
<span class="sd">    &gt;&gt;&gt; params = {&#39;input_channels&#39;: 2,</span>
<span class="sd">                  &#39;pred_size&#39;: 1,</span>
<span class="sd">                  &#39;window_size&#39;: 10,</span>
<span class="sd">                  &#39;rnn_window&#39;: 10}</span>
<span class="sd">    &gt;&gt;&gt; m = softsensor.autoreg_models.DensityEstimationARNN(**params, hidden_size=[16, 8])</span>
<span class="sd">    &gt;&gt;&gt; input = torch.randn(32, 2, 10)</span>
<span class="sd">    &gt;&gt;&gt; rec_input = torch.randn(32, 1, 10)</span>
<span class="sd">    &gt;&gt;&gt; output = m(input, rec_input)</span>
<span class="sd">    &gt;&gt;&gt; print(output[0].shape) #Mean Prediction</span>
<span class="sd">    torch.Size([32, 1, 1]) </span>
<span class="sd">    &gt;&gt;&gt; print(output[1].shape) #Var Prediction</span>
<span class="sd">    torch.Size([32, 1, 1]) </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_channels</span><span class="p">,</span> <span class="n">pred_size</span><span class="p">,</span> <span class="n">window_size</span><span class="p">,</span> <span class="n">rnn_window</span><span class="p">,</span>
                 <span class="n">hidden_size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">activation</span><span class="o">=</span><span class="s1">&#39;relu&#39;</span><span class="p">,</span> <span class="n">bias</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">dropout</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">forecast</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">concrete_dropout</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="n">bn</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="c1"># Define Linear Network with twice the forecast (mean and var of Gaussian)</span>
        <span class="n">ARNN</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_channels</span><span class="p">,</span> <span class="n">pred_size</span><span class="p">,</span> <span class="n">window_size</span><span class="p">,</span> <span class="n">rnn_window</span><span class="p">,</span>
                 <span class="n">hidden_size</span><span class="p">,</span> <span class="n">activation</span><span class="p">,</span> <span class="n">bias</span><span class="p">,</span> <span class="n">dropout</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">forecast</span><span class="p">,</span> <span class="n">concrete_dropout</span><span class="p">,</span> <span class="n">bn</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">params</span> <span class="o">=</span> <span class="n">_filter_parameters</span><span class="p">(</span><span class="nb">locals</span><span class="p">()</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">forecast</span> <span class="o">=</span> <span class="n">forecast</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Pred_Type</span> <span class="o">=</span> <span class="s1">&#39;Mean_Var&#39;</span>

<div class="viewcode-block" id="DensityEstimationARNN.forward">
<a class="viewcode-back" href="../../autoreg_models.html#softsensor.autoreg_models.DensityEstimationARNN.forward">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inp</span><span class="p">,</span> <span class="n">x_rec</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Forward function to propagate through the network</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        inp : torch.tensor dtype=torch.float</span>
<span class="sd">            Input tensor for forward propagation,</span>
<span class="sd">            shape=[batch size, external channels, window_size]</span>
<span class="sd">        x_rec : torch.tensor, dtype=torch.float</span>
<span class="sd">            Recurrent Input for forward Propagation.</span>
<span class="sd">            shape=[batch size, pred_size, rnn_window]</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        mean: torch.tensor dtype=torch.float()</span>
<span class="sd">            shape=[batch size, pred_size, forecast]</span>
<span class="sd">        var torch.tensor dtype=torch.float() in [0,1]</span>
<span class="sd">            shape=[batch size, pred_size, forecast]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">inp</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">inp</span><span class="p">,</span> <span class="n">start_dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">x_rec</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">x_rec</span><span class="p">,</span> <span class="n">start_dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">pred</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">DNN</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">((</span><span class="n">inp</span><span class="p">,</span> <span class="n">x_rec</span><span class="p">),</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">pred</span> <span class="o">=</span> <span class="n">pred</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pred_size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">forecast</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        
        <span class="n">mean</span><span class="p">,</span> <span class="n">hidden_std</span> <span class="o">=</span> <span class="n">pred</span><span class="p">[:,:,:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">pred</span><span class="p">[:,:,:,</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">var</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">softplus</span><span class="p">(</span><span class="n">hidden_std</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">mean</span><span class="p">,</span> <span class="n">var</span></div>


<div class="viewcode-block" id="DensityEstimationARNN.forward_sens">
<a class="viewcode-back" href="../../autoreg_models.html#softsensor.autoreg_models.DensityEstimationARNN.forward_sens">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">forward_sens</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inp</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Forward function to propagate through the network, but only with one input tensor</span>
<span class="sd">        that is already concatenated to allow for gradient-based sensitivity analysis</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        inp : torch.tensor dtype=torch.float</span>
<span class="sd">            Input tensor for forward propagation,</span>
<span class="sd">            shape=[batch size, external channels*window_size + pred_size*rnn_window]</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        mean: torch.tensor dtype=torch.float()</span>
<span class="sd">            shape=[batch size, pred_size, forecast]</span>
<span class="sd">        var torch.tensor dtype=torch.float() in [0,1]</span>
<span class="sd">            shape=[batch size, pred_size, forecast]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pred</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">DNN</span><span class="p">(</span><span class="n">inp</span><span class="p">)</span>
        <span class="n">pred</span> <span class="o">=</span> <span class="n">pred</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pred_size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">forecast</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        
        <span class="n">mean</span><span class="p">,</span> <span class="n">hidden_std</span> <span class="o">=</span> <span class="n">pred</span><span class="p">[:,:,:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">pred</span><span class="p">[:,:,:,</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">var</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">softplus</span><span class="p">(</span><span class="n">hidden_std</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">mean</span><span class="p">,</span> <span class="n">var</span></div>

    
<div class="viewcode-block" id="DensityEstimationARNN.estimate_uncertainty">
<a class="viewcode-back" href="../../autoreg_models.html#softsensor.autoreg_models.DensityEstimationARNN.estimate_uncertainty">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">estimate_uncertainty</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inp</span><span class="p">,</span> <span class="n">x_rec</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Wrapper of forward pass</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        inp : torch.tensor dtype=torch.float</span>
<span class="sd">            Input tensor for forward propagation,</span>
<span class="sd">            shape=[batch size, external channels, window_size]</span>
<span class="sd">        x_rec : torch.tensor, dtype=torch.float</span>
<span class="sd">            Recurrent Input for forward Propagation.</span>
<span class="sd">            shape=[batch size, pred_size, rnn_window]</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        (mean, var)</span>
<span class="sd">            mean: torch.tensor dtype=torch.float()</span>
<span class="sd">                shape=[batch size, pred_size]</span>

<span class="sd">            var: torch.tensor dtype=torch.float() in [0,1]</span>
<span class="sd">                shape=[batch size, pred_size]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">(</span><span class="n">inp</span><span class="p">,</span> <span class="n">x_rec</span><span class="p">)</span></div>


<div class="viewcode-block" id="DensityEstimationARNN.estimate_uncertainty_mean_std">
<a class="viewcode-back" href="../../autoreg_models.html#softsensor.autoreg_models.DensityEstimationARNN.estimate_uncertainty_mean_std">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">estimate_uncertainty_mean_std</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inp</span><span class="p">,</span> <span class="n">x_rec</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">(</span><span class="n">inp</span><span class="p">,</span> <span class="n">x_rec</span><span class="p">)</span></div>

    
<div class="viewcode-block" id="DensityEstimationARNN.prediction">
<a class="viewcode-back" href="../../autoreg_models.html#softsensor.autoreg_models.DensityEstimationARNN.prediction">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">prediction</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataloader</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="s1">&#39;cpu&#39;</span><span class="p">,</span> <span class="n">sens_params</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Prediction of a whole Time Series</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dataloader : Dataloader</span>
<span class="sd">            Dataloader to predict output</span>
<span class="sd">        device : str, optional</span>
<span class="sd">            device to compute on. The default is &#39;cpu&#39;.</span>
<span class="sd">        sens_params : dict, optional</span>
<span class="sd">            Dictionary that contains the parameters for the sensitivity analysis.</span>
<span class="sd">            Key &#39;method&#39; defines the method for sensitivity analysis: &#39;gradient&#39; or &#39;perturbation&#39;.</span>
<span class="sd">            Key &#39;comp&#39; defines whether gradients are computed for sensitivity analysis.</span>
<span class="sd">            Key &#39;plot&#39; defines whether the results of the sensitivity analysis are visualized.</span>
<span class="sd">            Key &#39;verbose&#39; defines whether the information about the sensitivity analysis is printed.</span>
<span class="sd">            Key &#39;sens_length&#39; defines the number of randomly sampled subset of timesteps for the analysis.</span>
<span class="sd">            The default is None, i.e. no sensitivity analysis is computed.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        if loss_ft=None:</span>
<span class="sd">            (torch.Tensor, list[torch.Tensor])</span>
<span class="sd">                tuple of Torch Tensor of same length as input and var</span>
<span class="sd">        if loss_ft=torch loss funciton:</span>
<span class="sd">            (torch.Tensor, list[torch.Tensor], loss)</span>
<span class="sd">                tuple of Torch Tensor of same length as input, var and loss</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_predict_arnn_uncertainty</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataloader</span><span class="p">,</span> <span class="n">device</span><span class="p">,</span> <span class="n">sens_params</span><span class="p">)</span></div>


<div class="viewcode-block" id="DensityEstimationARNN.get_recurrent_weights">
<a class="viewcode-back" href="../../autoreg_models.html#softsensor.autoreg_models.DensityEstimationARNN.get_recurrent_weights">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_recurrent_weights</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function that returns the weight that effect the Recurrent input of the</span>
<span class="sd">        Network (mean network)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        recurrent_weights : list of weight Tensors</span>
<span class="sd">            List of the Weights that effect the Recurrent input of the Network.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">input_pred_slice</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">rnn_window</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">pred_size</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_get_recurrent_weights</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">DNN</span><span class="o">.</span><span class="n">named_parameters</span><span class="p">(),</span> <span class="n">input_pred_slice</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span>
                                      <span class="bp">self</span><span class="o">.</span><span class="n">pred_size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">forecast</span><span class="p">)</span></div>
</div>


<div class="viewcode-block" id="SeparateMVEARNN">
<a class="viewcode-back" href="../../autoreg_models.html#softsensor.autoreg_models.SeparateMVEARNN">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">SeparateMVEARNN</span><span class="p">(</span><span class="n">ARNN</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ARNN with two independent subnetworks to predict mean and variance (aleatoric uncertainty)</span>
<span class="sd">    </span>
<span class="sd">    .. image:: C:/Users/wet2rng/Desktop/Coding/SoftSensor/doc/img/Separate_MVE.png</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    input_channels : int</span>
<span class="sd">        Number of input channels</span>
<span class="sd">    pred_size : int</span>
<span class="sd">        Number of predicted values</span>
<span class="sd">    window_size : int</span>
<span class="sd">        Size of the sliding window applied to the time series</span>
<span class="sd">    rnn_window : int</span>
<span class="sd">        Window Size of the Recurrent Connection before the DNN.</span>
<span class="sd">    mean_model : torch.Module</span>
<span class="sd">        Model for point prediction</span>
<span class="sd">    var_hidden_size : list[int] or None, optional</span>
<span class="sd">        List gives the size of hidden variance network units. The default is None.</span>
<span class="sd">    activation : str, optional</span>
<span class="sd">        Activation function to activate the feature space.</span>
<span class="sd">        The default is &#39;relu&#39;.</span>
<span class="sd">    bias : bool, optional</span>
<span class="sd">        If True, bias weights are used. The default is True.</span>
<span class="sd">    dropout : float [0,1], optional</span>
<span class="sd">        Adds dropout Layers after each Linear Layer. The default is None</span>
<span class="sd">    forecast : int, optional</span>
<span class="sd">        Size of the forecast. The default is 1</span>
<span class="sd">    concrete_dropout : bool, optional</span>
<span class="sd">        Whether to use normal or concrete dropout Layers if dropout is not None. The default is False</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    None.</span>
<span class="sd">    </span>
<span class="sd">    Note</span>
<span class="sd">    -------</span>
<span class="sd">    </span>
<span class="sd">    See &quot;Optimal Training of Mean Variance Estimation Neural Networks&quot;</span>
<span class="sd">    [Sluijterman et al. 2023 https://arxiv.org/abs/2302.08875]</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import softsensor.autoreg_models</span>
<span class="sd">    &gt;&gt;&gt; import torch</span>
<span class="sd">    &gt;&gt;&gt; params = {&#39;input_channels&#39;: 2,</span>
<span class="sd">                  &#39;pred_size&#39;: 1,</span>
<span class="sd">                  &#39;window_size&#39;: 10,</span>
<span class="sd">                  &#39;rnn_window&#39;: 10}</span>
<span class="sd">    &gt;&gt;&gt; mean_model = softsensor.autoreg_models.ARNN(**params, hidden_size=[16, 8])</span>
<span class="sd">    &gt;&gt;&gt; m = softsensor.autoreg_models.SeparateMVEARNN(**params,mean_model=mean_model,</span>
<span class="sd">                                                      var_hidden_size=[16, 8])</span>
<span class="sd">    &gt;&gt;&gt; input = torch.randn(32, 2, 10)</span>
<span class="sd">    &gt;&gt;&gt; rec_input = torch.randn(32, 1, 10)</span>
<span class="sd">    &gt;&gt;&gt; output = m(input, rec_input)</span>
<span class="sd">    &gt;&gt;&gt; print(output[0].shape) #Mean Prediction</span>
<span class="sd">    torch.Size([32, 1, 1]) </span>
<span class="sd">    &gt;&gt;&gt; print(output[1].shape) #VarPrediction</span>
<span class="sd">    torch.Size([32, 1, 1]) </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_channels</span><span class="p">,</span> <span class="n">pred_size</span><span class="p">,</span> <span class="n">window_size</span><span class="p">,</span> <span class="n">rnn_window</span><span class="p">,</span> <span class="n">mean_model</span><span class="p">,</span> <span class="n">var_hidden_size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">activation</span><span class="o">=</span><span class="s1">&#39;relu&#39;</span><span class="p">,</span> <span class="n">bias</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">dropout</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">forecast</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">concrete_dropout</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">bn</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="c1"># Network for variance prediction</span>
        <span class="n">ARNN</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_channels</span><span class="p">,</span> <span class="n">pred_size</span><span class="p">,</span> <span class="n">window_size</span><span class="p">,</span> <span class="n">rnn_window</span><span class="p">,</span>
                 <span class="n">var_hidden_size</span><span class="p">,</span> <span class="n">activation</span><span class="p">,</span> <span class="n">bias</span><span class="p">,</span> <span class="n">dropout</span><span class="p">,</span> <span class="n">forecast</span><span class="p">,</span> <span class="n">concrete_dropout</span><span class="p">,</span> <span class="n">bn</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">params</span> <span class="o">=</span> <span class="n">_filter_parameters</span><span class="p">(</span><span class="nb">locals</span><span class="p">()</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>

        <span class="c1"># Network for mean prediction</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mean_model</span> <span class="o">=</span> <span class="n">mean_model</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Pred_Type</span> <span class="o">=</span> <span class="s1">&#39;Mean_Var&#39;</span>

<div class="viewcode-block" id="SeparateMVEARNN.forward">
<a class="viewcode-back" href="../../autoreg_models.html#softsensor.autoreg_models.SeparateMVEARNN.forward">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inp</span><span class="p">,</span> <span class="n">x_rec</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Forward function to propagate through the MVE network</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        inp : torch.tensor dtype=torch.float</span>
<span class="sd">            Input tensor for forward propagation,</span>
<span class="sd">            shape=[batch size, external channels, window_size]</span>
<span class="sd">        x_rec : torch.tensor, dtype=torch.float</span>
<span class="sd">            Recurrent Input for forward Propagation.</span>
<span class="sd">            shape=[batch size, pred_size, rnn_window]</span>
<span class="sd">            </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        mean: torch.tensor dtype=torch.float()</span>
<span class="sd">            shape=[batch size, pred_size, forecast]</span>
<span class="sd">        var: torch.tensor dtype=torch.float() in [0,1]</span>
<span class="sd">            shape=[batch size, pred_size, forecast]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">inp</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">inp</span><span class="p">,</span> <span class="n">start_dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">x_rec</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">x_rec</span><span class="p">,</span> <span class="n">start_dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">mean</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mean_model</span><span class="p">(</span><span class="n">inp</span><span class="p">,</span> <span class="n">x_rec</span><span class="p">)</span>

        <span class="n">hidden_std</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">DNN</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">((</span><span class="n">inp</span><span class="p">,</span> <span class="n">x_rec</span><span class="p">),</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">hidden_std</span> <span class="o">=</span> <span class="n">hidden_std</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pred_size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">forecast</span><span class="p">)</span>
        <span class="n">var</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">softplus</span><span class="p">(</span><span class="n">hidden_std</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">mean</span><span class="p">,</span> <span class="n">var</span></div>

    
<div class="viewcode-block" id="SeparateMVEARNN.forward_sens">
<a class="viewcode-back" href="../../autoreg_models.html#softsensor.autoreg_models.SeparateMVEARNN.forward_sens">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">forward_sens</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inp</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Forward function to propagate through the network, but only with one input tensor</span>
<span class="sd">        that is already concatenated to allow for gradient-based sensitivity analysis</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        inp : torch.tensor dtype=torch.float</span>
<span class="sd">            Input tensor for forward propagation,</span>
<span class="sd">            shape=[batch size, external channels*window_size + pred_size*rnn_window]</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        mean: torch.tensor dtype=torch.float()</span>
<span class="sd">            shape=[batch size, pred_size, forecast]</span>
<span class="sd">        var torch.tensor dtype=torch.float() in [0,1]</span>
<span class="sd">            shape=[batch size, pred_size, forecast]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mean</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mean_model</span><span class="o">.</span><span class="n">forward_sens</span><span class="p">(</span><span class="n">inp</span><span class="p">)</span>
        
        <span class="n">hidden_std</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">DNN</span><span class="p">(</span><span class="n">inp</span><span class="p">)</span>
        <span class="n">hidden_std</span> <span class="o">=</span> <span class="n">hidden_std</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pred_size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">forecast</span><span class="p">)</span>
        <span class="n">var</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">softplus</span><span class="p">(</span><span class="n">hidden_std</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">mean</span><span class="p">,</span> <span class="n">var</span></div>

    
<div class="viewcode-block" id="SeparateMVEARNN.estimate_uncertainty">
<a class="viewcode-back" href="../../autoreg_models.html#softsensor.autoreg_models.SeparateMVEARNN.estimate_uncertainty">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">estimate_uncertainty</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inp</span><span class="p">,</span> <span class="n">x_rec</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Wrapper of forward pass</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        inp : torch.tensor dtype=torch.float</span>
<span class="sd">            Input tensor for forward propagation,</span>
<span class="sd">            shape=[batch size, external channels, window_size]</span>
<span class="sd">        x_rec : torch.tensor, dtype=torch.float</span>
<span class="sd">            Recurrent Input for forward Propagation.</span>
<span class="sd">            shape=[batch size, pred_size, rnn_window]</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        (mean, var)</span>
<span class="sd">            mean: torch.tensor dtype=torch.float()</span>
<span class="sd">                shape=[batch size, pred_size]</span>

<span class="sd">            var: torch.tensor dtype=torch.float() in [0,1]</span>
<span class="sd">                shape=[batch size, pred_size]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">(</span><span class="n">inp</span><span class="p">,</span> <span class="n">x_rec</span><span class="p">)</span></div>


<div class="viewcode-block" id="SeparateMVEARNN.estimate_uncertainty_mean_std">
<a class="viewcode-back" href="../../autoreg_models.html#softsensor.autoreg_models.SeparateMVEARNN.estimate_uncertainty_mean_std">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">estimate_uncertainty_mean_std</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inp</span><span class="p">,</span> <span class="n">x_rec</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Wrapper of forward pass</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        inp : torch.tensor dtype=torch.float</span>
<span class="sd">            Input tensor for forward propagation,</span>
<span class="sd">            shape=[batch size, external channels, window_size]</span>
<span class="sd">        x_rec : torch.tensor, dtype=torch.float</span>
<span class="sd">            Recurrent Input for forward Propagation.</span>
<span class="sd">            shape=[batch size, pred_size, rnn_window]</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        (mean, var)</span>
<span class="sd">            mean: torch.tensor dtype=torch.float()</span>
<span class="sd">                shape=[batch size, pred_size]</span>

<span class="sd">            var: torch.tensor dtype=torch.float() in [0,1]</span>
<span class="sd">                shape=[batch size, pred_size]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">(</span><span class="n">inp</span><span class="p">,</span> <span class="n">x_rec</span><span class="p">)</span></div>


<div class="viewcode-block" id="SeparateMVEARNN.prediction">
<a class="viewcode-back" href="../../autoreg_models.html#softsensor.autoreg_models.SeparateMVEARNN.prediction">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">prediction</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataloader</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="s1">&#39;cpu&#39;</span><span class="p">,</span> <span class="n">sens_params</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Prediction of a whole Time Series</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dataloader : Dataloader</span>
<span class="sd">            Dataloader to predict output</span>
<span class="sd">        device : str, optional</span>
<span class="sd">            device to compute on. The default is &#39;cpu&#39;.</span>
<span class="sd">        sens_params : dict, optional</span>
<span class="sd">            Dictionary that contains the parameters for the sensitivity analysis.</span>
<span class="sd">            Key &#39;method&#39; defines the method for sensitivity analysis: &#39;gradient&#39; or &#39;perturbation&#39;.</span>
<span class="sd">            Key &#39;comp&#39; defines whether gradients are computed for sensitivity analysis.</span>
<span class="sd">            Key &#39;plot&#39; defines whether the results of the sensitivity analysis are visualized.</span>
<span class="sd">            Key &#39;verbose&#39; defines whether the information about the sensitivity analysis is printed.</span>
<span class="sd">            Key &#39;sens_length&#39; defines the number of randomly sampled subset of timesteps for the analysis.</span>
<span class="sd">            The default is None, i.e. no sensitivity analysis is computed.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        if loss_ft=None:</span>
<span class="sd">            (torch.Tensor, list[torch.Tensor])</span>
<span class="sd">                tuple of Torch Tensor of same length as input and var</span>
<span class="sd">        if loss_ft=torch loss function:</span>
<span class="sd">            (torch.Tensor, list[torch.Tensor], loss)</span>
<span class="sd">                tuple of Torch Tensor of same length as input, var and loss</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_predict_arnn_uncertainty</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataloader</span><span class="p">,</span> <span class="n">device</span><span class="p">,</span> <span class="n">sens_params</span><span class="p">)</span></div>



<div class="viewcode-block" id="SeparateMVEARNN.get_recurrent_weights">
<a class="viewcode-back" href="../../autoreg_models.html#softsensor.autoreg_models.SeparateMVEARNN.get_recurrent_weights">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_recurrent_weights</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function that returns the weight that effect the Recurrent input of the</span>
<span class="sd">        Network (mean network)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        recurrent_weights : list of weight Tensors</span>
<span class="sd">            List of the Weights that effect the Recurrent input of the Network.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">mean_model</span><span class="o">.</span><span class="n">get_recurrent_weights</span><span class="p">()</span></div>
</div>



<div class="viewcode-block" id="QuantileARNN">
<a class="viewcode-back" href="../../autoreg_models.html#softsensor.autoreg_models.QuantileARNN">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">QuantileARNN</span><span class="p">(</span><span class="n">ARNN</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ARNN with multiple outputs to predict quantiles</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    input_channels : int</span>
<span class="sd">        Number of input channels</span>
<span class="sd">    pred_size : int</span>
<span class="sd">        Number of predicted values</span>
<span class="sd">    window_size : int</span>
<span class="sd">        Size of the sliding window applied to the time series</span>
<span class="sd">    rnn_window : int</span>
<span class="sd">        Window Size of the Recurent Connection before the DNN.</span>
<span class="sd">    hidden_sizes : list of three lists of int or None, optional</span>
<span class="sd">        [hidden_mean_size, hidden_var_size, hidden_shared_size]</span>
<span class="sd">        List gives the size of hidden mean, variance and shared network units. The default is None.</span>
<span class="sd">    activation : str, optional</span>
<span class="sd">        Activation function to activate the feature space.</span>
<span class="sd">        The default is &#39;relu&#39;.</span>
<span class="sd">    bias : bool, optional</span>
<span class="sd">        If True, bias weights are used. The default is True.</span>
<span class="sd">    dropout : float [0,1], optional</span>
<span class="sd">        Adds dropout Layers after each Linear Layer. The default is None</span>
<span class="sd">    forecast : int, optional</span>
<span class="sd">        Size of the forecast. The default is 1</span>
<span class="sd">    concrete_dropout : bool, optional</span>
<span class="sd">        Whether to use normal or concrete dropout Layers if dropout is not None. The default is False</span>
<span class="sd">    n_quantiles: int, optional</span>
<span class="sd">        Number of quantiles to predict. The default is 39 (median and 19 PIs between 0 and 1)</span>
<span class="sd">    mean_model : torch.Module, optional</span>
<span class="sd">        Model for point prediction. The default is None</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    None.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_channels</span><span class="p">,</span> <span class="n">pred_size</span><span class="p">,</span> <span class="n">window_size</span><span class="p">,</span> <span class="n">rnn_window</span><span class="p">,</span>
                 <span class="n">hidden_size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">activation</span><span class="o">=</span><span class="s1">&#39;relu&#39;</span><span class="p">,</span> <span class="n">bias</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">dropout</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">forecast</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">concrete_dropout</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>  <span class="n">n_quantiles</span><span class="o">=</span><span class="mi">39</span><span class="p">,</span> <span class="n">mean_model</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">bn</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="n">ARNN</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_channels</span><span class="p">,</span> <span class="n">pred_size</span><span class="p">,</span> <span class="n">window_size</span><span class="p">,</span> <span class="n">rnn_window</span><span class="p">,</span>
                 <span class="n">hidden_size</span><span class="p">,</span> <span class="n">activation</span><span class="p">,</span> <span class="n">bias</span><span class="p">,</span> <span class="n">dropout</span><span class="p">,</span> <span class="n">n_quantiles</span><span class="o">*</span><span class="n">forecast</span><span class="p">,</span> <span class="n">concrete_dropout</span><span class="p">,</span> <span class="n">bn</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">params</span> <span class="o">=</span> <span class="n">_filter_parameters</span><span class="p">(</span><span class="nb">locals</span><span class="p">()</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_quantiles</span> <span class="o">=</span> <span class="n">n_quantiles</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">forecast</span> <span class="o">=</span> <span class="n">forecast</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_layers</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">hidden_size</span><span class="p">)</span> <span class="k">if</span> <span class="n">hidden_size</span> <span class="k">else</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mean_model</span> <span class="o">=</span> <span class="n">mean_model</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Pred_Type</span> <span class="o">=</span> <span class="s1">&#39;Quantile&#39;</span>

<div class="viewcode-block" id="QuantileARNN.forward">
<a class="viewcode-back" href="../../autoreg_models.html#softsensor.autoreg_models.QuantileARNN.forward">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inp</span><span class="p">,</span> <span class="n">x_rec</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Forward function to propagate through the quantile network</span>
<span class="sd">        </span>
<span class="sd">        If mean_model is not None but a point prediction model, the mean_model is used for point prediction</span>
<span class="sd">        This is useful to keep the point prediction frozen during training without teacher forcing</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        inp : torch.tensor dtype=torch.float</span>
<span class="sd">            Input tensor for forward propagation,</span>
<span class="sd">            shape=[batch size, external channels, window_size]</span>
<span class="sd">        x_rec : torch.tensor, dtype=torch.float</span>
<span class="sd">            Recurrent Input for forward Propagation.</span>
<span class="sd">            shape=[batch size, pred_size, rnn_window]</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pred: torch.tensor dtype=torch.float()</span>
<span class="sd">            shape=[batch size, pred_size, n_quantiles]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">inp</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">inp</span><span class="p">,</span> <span class="n">start_dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">x_rec</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">x_rec</span><span class="p">,</span> <span class="n">start_dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        
        <span class="n">pred</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">DNN</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">((</span><span class="n">inp</span><span class="p">,</span> <span class="n">x_rec</span><span class="p">),</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">pred</span> <span class="o">=</span> <span class="n">pred</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pred_size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">forecast</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_quantiles</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mean_model</span><span class="p">:</span>
            <span class="n">pred</span><span class="p">[</span><span class="o">...</span><span class="p">,:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mean_model</span><span class="p">(</span><span class="n">inp</span><span class="p">,</span> <span class="n">x_rec</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">pred</span></div>

    
<div class="viewcode-block" id="QuantileARNN.prediction">
<a class="viewcode-back" href="../../autoreg_models.html#softsensor.autoreg_models.QuantileARNN.prediction">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">prediction</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataloader</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="s1">&#39;cpu&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Prediction of a whole Time Series</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dataloader : Dataloader</span>
<span class="sd">            Dataloader to predict output</span>
<span class="sd">        device : str, optional</span>
<span class="sd">            device to compute on. The default is &#39;cpu&#39;.</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        if loss_ft=None:</span>
<span class="sd">            quantiles: list[torch.Tensor]</span>
<span class="sd">                list of n_quantile tensors of same length as input</span>
<span class="sd">        if loss_ft=torch loss funciton:</span>
<span class="sd">            (list[torch.Tensor], loss)</span>
<span class="sd">                list of n_quantile tensors of same length as input and loss</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_prediction</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataloader</span><span class="p">,</span> <span class="n">device</span><span class="p">)</span></div>

    
<div class="viewcode-block" id="QuantileARNN.get_recurrent_weights">
<a class="viewcode-back" href="../../autoreg_models.html#softsensor.autoreg_models.QuantileARNN.get_recurrent_weights">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_recurrent_weights</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function that returns the weight that effect the Recurrent input of the</span>
<span class="sd">        Network (mean network)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        recurrent_weights : list of weight Tensors</span>
<span class="sd">            List of the Weights that effect the Recurrent input of the Network.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">input_pred_slice</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">rnn_window</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">pred_size</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_get_recurrent_weights</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">DNN</span><span class="o">.</span><span class="n">named_parameters</span><span class="p">(),</span> <span class="n">input_pred_slice</span><span class="p">,</span>
                                      <span class="n">distribution_layer</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>
</div>


<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">helpers</span>
<span class="sd">&#39;&#39;&#39;</span>
<span class="k">def</span><span class="w"> </span><span class="nf">_get_recurrent_weights</span><span class="p">(</span><span class="n">parameters</span><span class="p">,</span> <span class="n">input_pred_slice</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">distribution_layer</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">pred_size</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">forecast</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="n">Layer</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">recurrent_weights</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">W</span> <span class="ow">in</span> <span class="n">parameters</span><span class="p">:</span>
        <span class="k">if</span> <span class="s1">&#39;weight&#39;</span> <span class="ow">in</span> <span class="n">name</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">input_pred_slice</span> <span class="ow">and</span> <span class="n">Layer</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">temp_weights</span> <span class="o">=</span> <span class="n">W</span><span class="p">[:,</span> <span class="n">input_pred_slice</span><span class="p">]</span>
                <span class="n">recurrent_weights</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">temp_weights</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">recurrent_weights</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">W</span><span class="p">)</span>
            <span class="n">Layer</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">if</span> <span class="n">distribution_layer</span><span class="p">:</span>
        <span class="c1">#recurrent_weights[-1] = recurrent_weights[-1][0, :]</span>
        <span class="n">recurrent_weights</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">recurrent_weights</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][:</span><span class="n">pred_size</span><span class="o">*</span><span class="n">forecast</span><span class="p">,</span> <span class="p">:]</span>

    <span class="k">return</span> <span class="n">recurrent_weights</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_forward_AR</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">inp</span><span class="p">,</span> <span class="n">x_rec</span><span class="p">):</span>
    <span class="n">inp</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">([</span><span class="n">inp</span><span class="p">,</span> <span class="n">x_rec</span><span class="p">],</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="n">inp</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">ConvNet</span><span class="p">(</span><span class="n">inp</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">model</span><span class="o">.</span><span class="n">bn</span><span class="p">:</span>
        <span class="n">inp</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">BNLayer</span><span class="p">(</span><span class="n">inp</span><span class="p">)</span>
    <span class="n">inp</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">inp</span><span class="p">,</span> <span class="n">start_dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">inp</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">DNN</span><span class="p">(</span><span class="n">inp</span><span class="p">)</span>
    <span class="n">inp</span> <span class="o">=</span> <span class="n">inp</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">model</span><span class="o">.</span><span class="n">pred_size</span><span class="p">,</span> <span class="n">model</span><span class="o">.</span><span class="n">forecast</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">inp</span>



<span class="k">def</span><span class="w"> </span><span class="nf">_predict_ARNN</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">dataloader</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="s1">&#39;cpu&#39;</span><span class="p">,</span> <span class="n">sens_params</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Predict function for forward ARNN models</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    model : Model consisting of nn.Modules</span>
<span class="sd">    dataloader : Dataloader</span>
<span class="sd">        Dataloader to predict output</span>
<span class="sd">    device : str, optional</span>
<span class="sd">        device to compute on. The default is &#39;cpu&#39;.</span>
<span class="sd">    sens_params : dict, optional</span>
<span class="sd">        Dictionary that contains the parameters for the sensitivity analysis.</span>
<span class="sd">        Key &#39;method&#39; defines the method for sensitivity analysis: &#39;gradient&#39; or &#39;perturbation&#39;.</span>
<span class="sd">        Key &#39;comp&#39; defines whether gradients are computed for sensitivity analysis.</span>
<span class="sd">        Key &#39;plot&#39; defines whether the results of the sensitivity analysis are visualized.</span>
<span class="sd">        Key &#39;verbose&#39; defines whether the information about the sensitivity analysis is printed.</span>
<span class="sd">        Key &#39;sens_length&#39; defines the number of randomly sampled subset of timesteps for the analysis.</span>
<span class="sd">        (If not a multiple of the model&#39;s forecast, the number will be rounded up to the next multiple.)</span>
<span class="sd">        The default is None, i.e. no sensitivity analysis is computed.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    if comp_sens is False:</span>
<span class="sd">        torch.Tensor : Tensor of same langth as input, containing the predictions.</span>
<span class="sd">    if comp_sens is True:</span>
<span class="sd">        (torch.Tensor, dict) : Tuple of Tensor of same length as input and sensitivity dict.</span>
<span class="sd">        Key is the prediction type, value is the sensitivity tensor.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">fc</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">forecast</span>
    <span class="c1"># The Model starts with zeros as recurrent System state</span>
    <span class="n">size</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">window_size</span><span class="p">,</span> <span class="n">model</span><span class="o">.</span><span class="n">rnn_window</span><span class="p">)</span>
    <span class="n">prediction</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">model</span><span class="o">.</span><span class="n">pred_size</span><span class="p">,</span> <span class="n">size</span><span class="p">))</span>
    <span class="n">original_out</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">model</span><span class="o">.</span><span class="n">pred_size</span><span class="p">,</span> <span class="n">size</span><span class="p">))</span>
    <span class="n">x_rec</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">model</span><span class="o">.</span><span class="n">pred_size</span><span class="p">,</span> <span class="n">model</span><span class="o">.</span><span class="n">rnn_window</span><span class="p">)</span>

    <span class="c1"># Tensors to device</span>
    <span class="n">x_rec</span> <span class="o">=</span> <span class="n">x_rec</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>
    <span class="n">prediction</span> <span class="o">=</span> <span class="n">prediction</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>
    <span class="n">original_out</span> <span class="o">=</span> <span class="n">original_out</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>
    <span class="n">model</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>

    <span class="n">checks</span> <span class="o">=</span> <span class="n">_check_sens_params_pred</span><span class="p">(</span><span class="n">sens_params</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">sens_params</span><span class="p">:</span>
        <span class="n">method</span><span class="p">,</span> <span class="n">comp_sens</span><span class="p">,</span> <span class="n">verbose</span><span class="p">,</span> <span class="n">sens_length</span><span class="p">,</span> <span class="n">num_samples</span><span class="p">,</span> <span class="n">std_dev</span><span class="p">,</span> <span class="n">correlated</span> <span class="o">=</span> <span class="n">checks</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">comp_sens</span><span class="p">,</span> <span class="n">verbose</span> <span class="o">=</span> <span class="n">checks</span> <span class="c1"># False</span>

    <span class="c1"># Initialise 3D tensor for sensitivity analysis</span>
    <span class="k">if</span> <span class="n">comp_sens</span><span class="p">:</span>
        <span class="n">flatten_size</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">window_size</span><span class="o">*</span><span class="n">model</span><span class="o">.</span><span class="n">input_channels</span> <span class="o">+</span> <span class="n">model</span><span class="o">.</span><span class="n">rnn_window</span><span class="o">*</span><span class="n">model</span><span class="o">.</span><span class="n">pred_size</span>
        <span class="n">num_timesteps</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">dataloader</span><span class="p">)</span><span class="o">*</span><span class="n">fc</span>
        <span class="n">loader_length</span> <span class="o">=</span> <span class="n">num_timesteps</span> <span class="o">-</span> <span class="n">dataloader</span><span class="o">.</span><span class="n">dataset</span><span class="o">.</span><span class="n">subclass</span><span class="o">.</span><span class="n">add_zero</span>
        <span class="n">sens_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dataloader</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">sens_length</span><span class="p">:</span>
            <span class="n">num_timesteps</span><span class="p">,</span> <span class="n">sens_indices</span> <span class="o">=</span> <span class="n">_random_subset_sens_indices</span><span class="p">(</span><span class="n">sens_length</span><span class="p">,</span> <span class="n">fc</span><span class="p">,</span> <span class="n">model</span><span class="o">.</span><span class="n">Type</span><span class="p">,</span> <span class="n">dataloader</span><span class="p">)</span>
        
        <span class="n">sensitivity</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">num_timesteps</span><span class="p">,</span> <span class="n">model</span><span class="o">.</span><span class="n">pred_size</span><span class="p">,</span> <span class="n">flatten_size</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Shape of sensitivity tensor: </span><span class="si">{</span><span class="n">sensitivity</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Start </span><span class="si">{</span><span class="n">method</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span><span class="si">}</span><span class="s1">-based Sensitivity Analysis...</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>

    <span class="c1"># Iterate over dataloader</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">data</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">tqdm</span><span class="p">(</span><span class="n">dataloader</span><span class="p">)</span> <span class="k">if</span> <span class="n">verbose</span> <span class="k">else</span> <span class="n">dataloader</span><span class="p">):</span>
        <span class="n">inputs</span><span class="p">,</span> <span class="n">output</span> <span class="o">=</span> <span class="n">data</span>
        <span class="n">inputs</span><span class="p">,</span> <span class="n">output</span> <span class="o">=</span> <span class="n">inputs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">),</span> <span class="n">output</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>

        <span class="c1"># Prepare input for model to allow autograd computing gradients of outputs w.r.t. inputs</span>
        <span class="n">inputs</span> <span class="o">=</span> <span class="n">Variable</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="n">start_dim</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="n">requires_grad</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">x_rec</span> <span class="o">=</span> <span class="n">Variable</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">x_rec</span><span class="p">,</span> <span class="n">start_dim</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="n">requires_grad</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">inp</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">((</span><span class="n">inputs</span><span class="p">,</span> <span class="n">x_rec</span><span class="p">),</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">pred</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">forward_sens</span><span class="p">(</span><span class="n">inp</span><span class="p">)</span> <span class="k">if</span> <span class="n">comp_sens</span> <span class="k">else</span> <span class="n">model</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="n">x_rec</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">comp_sens</span> <span class="ow">and</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">sens_indices</span><span class="p">:</span>
            <span class="n">sensitivity</span><span class="p">[</span><span class="n">idx</span><span class="p">:</span><span class="n">idx</span><span class="o">+</span><span class="n">fc</span><span class="p">]</span> <span class="o">=</span> <span class="n">_comp_sensitivity</span><span class="p">(</span><span class="n">method</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">inp</span><span class="p">,</span> <span class="n">pred</span><span class="p">,</span> <span class="n">num_samples</span><span class="p">,</span> <span class="n">std_dev</span><span class="p">,</span> <span class="n">correlated</span><span class="p">)</span>
            <span class="n">idx</span> <span class="o">+=</span> <span class="n">fc</span>
        
        <span class="n">prediction</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">((</span><span class="n">prediction</span><span class="p">,</span>
                                <span class="n">pred</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">pred_size</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)),</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="c1"># Recurrent Input that is used for the next prediction -&gt; autoregressive feedback!</span>
        <span class="n">x_rec</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="n">prediction</span><span class="p">[:,</span> <span class="o">-</span><span class="n">model</span><span class="o">.</span><span class="n">rnn_window</span><span class="p">:],</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">original_out</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">((</span><span class="n">original_out</span><span class="p">,</span>
                                  <span class="n">output</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">pred_size</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)),</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    
    <span class="c1"># cut zeros from initialisation</span>
    <span class="n">prediction</span> <span class="o">=</span> <span class="n">prediction</span><span class="p">[:,</span> <span class="n">size</span><span class="p">:]</span> <span class="c1"># shape = [pred_size, len(dataloader)]</span>
    <span class="n">original_out</span> <span class="o">=</span> <span class="n">original_out</span><span class="p">[:,</span> <span class="n">size</span><span class="p">:]</span>

    <span class="n">cut_zeros</span> <span class="o">=</span> <span class="n">dataloader</span><span class="o">.</span><span class="n">dataset</span><span class="o">.</span><span class="n">subclass</span><span class="o">.</span><span class="n">add_zero</span>
    <span class="k">if</span> <span class="n">cut_zeros</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">prediction</span> <span class="o">=</span> <span class="n">prediction</span><span class="p">[:,</span> <span class="p">:</span><span class="o">-</span><span class="n">cut_zeros</span><span class="p">]</span>
        <span class="n">original_out</span> <span class="o">=</span> <span class="n">original_out</span><span class="p">[:,</span> <span class="p">:</span><span class="o">-</span><span class="n">cut_zeros</span><span class="p">]</span>

    <span class="n">prediction</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span>
    <span class="n">model</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="s1">&#39;cpu&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">comp_sens</span><span class="p">:</span>
        <span class="n">sensitivity</span> <span class="o">=</span> <span class="n">sensitivity</span><span class="p">[:</span><span class="n">loader_length</span><span class="p">]</span>
        <span class="n">sensitivity_dict</span> <span class="o">=</span> <span class="p">{</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">model</span><span class="o">.</span><span class="n">Pred_Type</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">:</span> <span class="n">sensitivity</span><span class="o">.</span><span class="n">cpu</span><span class="p">()}</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">method</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span><span class="si">}</span><span class="s1">-based Sensitivity Analysis completed!</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">prediction</span><span class="p">,</span> <span class="n">sensitivity_dict</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">prediction</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_comp_grad_sens</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="n">pred</span><span class="p">,</span> <span class="n">pred_type</span><span class="p">,</span> <span class="n">ensemble</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">random_samples</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">amplification</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the gradient-based sensitivity of the output w.r.t. the inputs in each timestep.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    inputs : torch.Tensor</span>
<span class="sd">        Input tensor with already concatenated external excitation and recurrent state signals,</span>
<span class="sd">        shape=[batch_size, input_channels*window_size + pred_size*rnn_window]</span>
<span class="sd">    pred : torch.Tensor</span>
<span class="sd">        Output tensor that contains the predictions,</span>
<span class="sd">        shape=[batch_size, pred_size, forecast]</span>
<span class="sd">    pred_type : str</span>
<span class="sd">        The model&#39;s prediction type out of (&#39;Point, &#39;Mean_Var&#39;), which defines</span>
<span class="sd">        the number of outputs that the sensitivity analysis is performed on.</span>
<span class="sd">    ensemble : bool, optional</span>
<span class="sd">        If True, sensitivity is computed for an ensemble of models. The default is False.</span>
<span class="sd">    random_samples : int, optional</span>
<span class="sd">        Number of random samples, drawn from a standard normal distribution, to approximate the</span>
<span class="sd">        expected sensitivity range/distribution across the aleatoric uncertainty of MVE models.</span>
<span class="sd">        The default is 0 samples, i.e. no sampling is performed.</span>
<span class="sd">    amplification : float, optional</span>
<span class="sd">        Amplification factor for the uncertainty quantification of the sensitivity analysis.</span>
<span class="sd">        Only applicable for MVE models and only used if random_samples &gt; 0. The default is 1.</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    sens_temp : torch.Tensor</span>
<span class="sd">        Sensitivity tensor as Jacobian that contains the gradients of the output w.r.t. the inputs,</span>
<span class="sd">        shape=[batch_size*forecast, pred_size, input_channels*window_size + pred_size*rnn_window]</span>
<span class="sd">    sens_temp_mean : torch.Tensor, optional</span>
<span class="sd">        Sensitivity tensor that contains the gradients of the mean output w.r.t. the inputs when using MVE models.</span>
<span class="sd">    sens_temp_var : torch.Tensor, optional</span>
<span class="sd">        Sensitivity tensor that contains the gradients of the aleatoric variance output w.r.t. the inputs when using MVE models.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">batch_size</span><span class="p">,</span> <span class="n">pred_size</span><span class="p">,</span> <span class="n">forecast</span> <span class="o">=</span> <span class="n">pred</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span> <span class="k">if</span> <span class="p">(</span><span class="n">pred_type</span> <span class="o">==</span> <span class="s1">&#39;Mean_Var&#39;</span> <span class="ow">or</span> <span class="n">ensemble</span><span class="p">)</span> <span class="k">else</span> <span class="n">pred</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">flatten_size</span> <span class="o">=</span> <span class="n">inputs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">jacobian</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="n">pred</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the Jacobian of the output w.r.t. the inputs for one timestep.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># initialize Jacobian tensor with NaNs</span>
        <span class="n">jac</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">batch_size</span><span class="o">*</span><span class="n">forecast</span><span class="p">,</span> <span class="n">pred_size</span><span class="p">,</span> <span class="n">flatten_size</span><span class="p">),</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;nan&#39;</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">forecast</span><span class="p">):</span> <span class="c1"># loop over forecasting horizon</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">pred_size</span><span class="p">):</span> <span class="c1"># loop over output channels</span>
                <span class="c1"># shape [batch_size, input_channels*window_size + pred_size*rnn_window]</span>
                <span class="n">grad_temp</span> <span class="o">=</span> <span class="n">grad</span><span class="p">(</span><span class="n">pred</span><span class="p">[:,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">],</span> <span class="n">inputs</span><span class="p">,</span> <span class="n">grad_outputs</span><span class="o">=</span>
                                <span class="n">torch</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">pred</span><span class="p">[:,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">]),</span> <span class="n">create_graph</span><span class="o">=</span><span class="kc">True</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">j</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">jac_temp</span> <span class="o">=</span> <span class="n">grad_temp</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">jac_temp</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">((</span><span class="n">jac_temp</span><span class="p">,</span> <span class="n">grad_temp</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">1</span><span class="p">)),</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">jac</span><span class="p">[</span><span class="n">k</span><span class="p">::</span><span class="n">forecast</span><span class="p">]</span> <span class="o">=</span> <span class="n">jac_temp</span>
        <span class="k">return</span> <span class="n">jac</span> <span class="c1"># shape [batch_size*forecast, pred_size, flatten_size]</span>
        <span class="c1"># return jac * inputs.unsqueeze(1).detach() # gradient * input -&gt; between pure gradient &amp; IG!</span>
    
    <span class="c1"># Compute and return the gradients</span>
    <span class="k">if</span> <span class="n">pred_type</span> <span class="o">==</span> <span class="s1">&#39;Point&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">jacobian</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="n">pred</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">pred_type</span> <span class="o">==</span> <span class="s1">&#39;Mean_Var&#39;</span> <span class="ow">or</span> <span class="n">ensemble</span><span class="p">:</span>
        <span class="n">mean_pred</span><span class="p">,</span> <span class="n">var_pred</span> <span class="o">=</span> <span class="n">pred</span>
        <span class="n">sens_temp_mean</span> <span class="o">=</span> <span class="n">jacobian</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="n">mean_pred</span><span class="p">)</span>
        <span class="n">sens_temp_var</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">sens_temp_mean</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">random_samples</span><span class="p">:</span>
            <span class="n">grads</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">random_samples</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">*</span><span class="n">forecast</span><span class="p">,</span> <span class="n">pred_size</span><span class="p">,</span> <span class="n">flatten_size</span><span class="p">),</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;nan&#39;</span><span class="p">))</span>
            <span class="n">samples</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">random_samples</span><span class="p">,</span> <span class="n">pred_size</span><span class="p">),</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;nan&#39;</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">random_samples</span><span class="p">):</span> <span class="c1"># not direct sampling, but reparametrization trick: mean + eps*std, with eps ~ N(0,1)</span>
                <span class="n">eps</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">pred_size</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">amplification</span> <span class="c1"># used for later up-scaling</span>
                <span class="n">sampled_pred</span> <span class="o">=</span> <span class="n">mean_pred</span> <span class="o">+</span> <span class="n">eps</span> <span class="o">*</span> <span class="n">torch</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">var_pred</span><span class="p">)</span>
                <span class="n">grads</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">jacobian</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="n">sampled_pred</span><span class="p">)</span>
                <span class="n">samples</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">eps</span><span class="p">[</span><span class="mi">0</span><span class="p">,:,</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span>
            <span class="n">sens_temp_var</span> <span class="o">=</span> <span class="n">grads</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">sens_temp_mean</span><span class="p">,</span> <span class="n">sens_temp_var</span><span class="p">,</span> <span class="n">grads</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="n">samples</span>
        <span class="k">return</span> <span class="n">sens_temp_mean</span><span class="p">,</span> <span class="n">sens_temp_var</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_comp_smooth_grad_sens</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">inputs</span><span class="p">,</span> <span class="n">pred</span><span class="p">,</span> <span class="n">pred_type</span><span class="p">,</span> <span class="n">ensemble</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">num_samples</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">std_dev</span><span class="o">=</span><span class="mf">0.2</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the SmoothGrad-based sensitivity of the output w.r.t. the inputs in each timestep.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    model : Model consisting of nn.Modules</span>
<span class="sd">    inputs : torch.Tensor</span>
<span class="sd">        Input tensor with already concatenated external excitation and recurrent state signals,</span>
<span class="sd">        shape=[batch_size, input_channels*window_size + pred_size*rnn_window]</span>
<span class="sd">    pred : torch.Tensor</span>
<span class="sd">        Output tensor that contains the predictions,</span>
<span class="sd">        shape=[batch_size, pred_size, forecast]</span>
<span class="sd">    pred_type : str</span>
<span class="sd">        The model&#39;s prediction type out of (&#39;Point&#39;, &#39;Mean_Var&#39;), which defines</span>
<span class="sd">        the number of outputs that the sensitivity analysis is performed on.</span>
<span class="sd">    ensemble : bool, optional</span>
<span class="sd">        If True, sensitivity is computed for an ensemble of models. The default is False.</span>
<span class="sd">    num_samples : int, optional</span>
<span class="sd">        Number of noisy samples to generate. The default is 10.</span>
<span class="sd">    std_dev : float, optional</span>
<span class="sd">        Standard deviation used for sampling the noisy variations of the input. The default is 0.1.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    sens_temp : torch.Tensor</span>
<span class="sd">        Sensitivity tensor as Jacobian that contains the gradients of the output w.r.t. the inputs,</span>
<span class="sd">        shape=[batch_size*forecast, pred_size, flatten_size]</span>
<span class="sd">    sens_temp_mean : torch.Tensor, optional</span>
<span class="sd">        Sensitivity tensor that contains the gradients of the mean output w.r.t. the inputs when using MVE models.</span>
<span class="sd">    sens_temp_var : torch.Tensor, optional</span>
<span class="sd">        Sensitivity tensor that contains the gradients of the aleatoric variance output w.r.t.</span>
<span class="sd">        the inputs when using MVE models.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    AssertionError</span>
<span class="sd">        If the number of samples is less than 1 or the standard deviation is less than 0.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="n">num_samples</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;Number of samples must be greater than 0 for SmoothGrad!&#39;</span>
    <span class="k">assert</span> <span class="n">std_dev</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;Standard deviation for Gaussian noise must be greater than 0 for SmoothGrad!&#39;</span>

    <span class="n">batch_size</span><span class="p">,</span> <span class="n">pred_size</span><span class="p">,</span> <span class="n">forecast</span> <span class="o">=</span> <span class="n">pred</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span> <span class="k">if</span> <span class="p">(</span><span class="n">pred_type</span> <span class="o">==</span> <span class="s1">&#39;Mean_Var&#39;</span> <span class="ow">or</span> <span class="n">ensemble</span><span class="p">)</span> <span class="k">else</span> <span class="n">pred</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">flatten_size</span> <span class="o">=</span> <span class="n">inputs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">smooth_grad</span><span class="p">():</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the SmoothGrad sensitivity of the output w.r.t. the inputs for one timestep.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">pred_type</span> <span class="o">==</span> <span class="s1">&#39;Point&#39;</span><span class="p">:</span>
            <span class="n">gradients</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">num_samples</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">*</span><span class="n">forecast</span><span class="p">,</span> <span class="n">pred_size</span><span class="p">,</span> <span class="n">flatten_size</span><span class="p">),</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;nan&#39;</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">gradients_mean</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">num_samples</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">*</span><span class="n">forecast</span><span class="p">,</span> <span class="n">pred_size</span><span class="p">,</span> <span class="n">flatten_size</span><span class="p">),</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;nan&#39;</span><span class="p">))</span>
            <span class="n">gradients_var</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">num_samples</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">*</span><span class="n">forecast</span><span class="p">,</span> <span class="n">pred_size</span><span class="p">,</span> <span class="n">flatten_size</span><span class="p">),</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;nan&#39;</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_samples</span><span class="p">):</span>
            <span class="n">noise</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">randn_like</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="n">requires_grad</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">*</span> <span class="n">std_dev</span>
            <span class="n">inputs_noisy</span> <span class="o">=</span> <span class="n">inputs</span> <span class="o">+</span> <span class="n">noise</span>
            <span class="n">pred_noisy</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">forward_sens</span><span class="p">(</span><span class="n">inputs_noisy</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_samples</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">grads</span> <span class="o">=</span> <span class="n">_comp_grad_sens</span><span class="p">(</span><span class="n">inputs_noisy</span><span class="p">,</span> <span class="n">pred_noisy</span><span class="p">,</span> <span class="n">pred_type</span><span class="p">,</span> <span class="n">ensemble</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span> <span class="c1"># compute gradients for the original input</span>
                <span class="n">grads</span> <span class="o">=</span> <span class="n">_comp_grad_sens</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="n">pred</span><span class="p">,</span> <span class="n">pred_type</span><span class="p">,</span> <span class="n">ensemble</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">pred_type</span> <span class="o">==</span> <span class="s1">&#39;Point&#39;</span><span class="p">:</span>
                <span class="n">gradients</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">grads</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">gradients_mean</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">gradients_var</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">grads</span>
            
        <span class="k">if</span> <span class="n">pred_type</span> <span class="o">==</span> <span class="s1">&#39;Point&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">gradients</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">pred_type</span> <span class="o">==</span> <span class="s1">&#39;Mean_Var&#39;</span> <span class="ow">or</span> <span class="n">ensemble</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">gradients_mean</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span> <span class="n">gradients_var</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">smooth_grad</span><span class="p">()</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_comp_integrated_grad_sens</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">inputs</span><span class="p">,</span> <span class="n">pred</span><span class="p">,</span> <span class="n">pred_type</span><span class="p">,</span> <span class="n">ensemble</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">num_steps</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the integrated gradient-based sensitivity of the output w.r.t. the inputs in each timestep.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    model : Model consisting of nn.Modules</span>
<span class="sd">    inputs : torch.Tensor</span>
<span class="sd">        Input tensor with already concatenated external excitation and recurrent state signals,</span>
<span class="sd">        shape=[batch_size, input_channels*window_size + pred_size*rnn_window]</span>
<span class="sd">    pred : torch.Tensor</span>
<span class="sd">        Output tensor that contains the predictions,</span>
<span class="sd">        shape=[batch_size, pred_size, forecast]</span>
<span class="sd">    pred_type : str</span>
<span class="sd">        The model&#39;s prediction type out of (&#39;Point, &#39;Mean_Var&#39;), which defines</span>
<span class="sd">        the number of outputs that the sensitivity analysis is performed on.</span>
<span class="sd">    ensemble : bool, optional</span>
<span class="sd">        If True, sensitivity is computed for an ensemble of models. The default is False.</span>
<span class="sd">    num_steps : int, optional</span>
<span class="sd">        Number of steps along the linearly interpolated path from the baseline to the input.</span>
<span class="sd">        The default is 4 steps.</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    sens_temp : torch.Tensor</span>
<span class="sd">        Sensitivity tensor as Jacobian that contains the gradients of the output w.r.t. the inputs,</span>
<span class="sd">        shape=[batch_size*forecast, pred_size, input_channels*window_size + pred_size*rnn_window]</span>
<span class="sd">    sens_temp_mean : torch.Tensor, optional</span>
<span class="sd">        Sensitivity tensor that contains the gradients of the mean output w.r.t. the inputs when using MVE models.</span>
<span class="sd">    sens_temp_var : torch.Tensor, optional</span>
<span class="sd">        Sensitivity tensor that contains the gradients of the aleatoric variance output w.r.t. the inputs when using MVE models.</span>
<span class="sd">    </span>
<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    AssertionError</span>
<span class="sd">        If the number of steps is less than 2.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="n">num_steps</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;Number of integration steps must be greater than 1 for IG!&#39;</span>

    <span class="n">batch_size</span><span class="p">,</span> <span class="n">pred_size</span><span class="p">,</span> <span class="n">forecast</span> <span class="o">=</span> <span class="n">pred</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span> <span class="k">if</span> <span class="p">(</span><span class="n">pred_type</span> <span class="o">==</span> <span class="s1">&#39;Mean_Var&#39;</span> <span class="ow">or</span> <span class="n">ensemble</span><span class="p">)</span> <span class="k">else</span> <span class="n">pred</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">flatten_size</span> <span class="o">=</span> <span class="n">inputs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">alphas</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">num_steps</span><span class="o">+</span><span class="mi">1</span><span class="p">)[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="c1"># exclude the baseline bc it&#39;s zero</span>
    <span class="n">baseline_inp</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span> <span class="c1"># zero baseline</span>
    <span class="c1"># baseline_inp = torch.mean(inputs, dim=1, keepdim=True).repeat(1, flatten_size) # mean baseline as alternative option</span>
    <span class="n">difference_inp</span> <span class="o">=</span> <span class="p">(</span><span class="n">inputs</span> <span class="o">-</span> <span class="n">baseline_inp</span><span class="p">)</span><span class="o">.</span><span class="n">repeat_interleave</span><span class="p">(</span><span class="n">forecast</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">integrated_grads</span><span class="p">(</span><span class="n">alphas</span><span class="p">,</span> <span class="n">baseline_inp</span><span class="p">,</span> <span class="n">difference_inp</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the integrated gradients of the output w.r.t. the inputs for one timestep.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">gradients_mean</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">num_steps</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">*</span><span class="n">forecast</span><span class="p">,</span> <span class="n">pred_size</span><span class="p">,</span> <span class="n">flatten_size</span><span class="p">),</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;nan&#39;</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">pred_type</span> <span class="o">==</span> <span class="s1">&#39;Mean_Var&#39;</span> <span class="ow">or</span> <span class="n">ensemble</span><span class="p">:</span>
            <span class="n">gradients_var</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">num_steps</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">*</span><span class="n">forecast</span><span class="p">,</span> <span class="n">pred_size</span><span class="p">,</span> <span class="n">flatten_size</span><span class="p">),</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;nan&#39;</span><span class="p">))</span>
        
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">alpha</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">alphas</span><span class="p">):</span>
            <span class="n">inputs_interpol</span> <span class="o">=</span> <span class="n">baseline_inp</span> <span class="o">+</span> <span class="n">alpha</span> <span class="o">*</span> <span class="p">(</span><span class="n">inputs</span> <span class="o">-</span> <span class="n">baseline_inp</span><span class="p">)</span> <span class="c1"># interpolate between baseline and input</span>
            <span class="n">pred_interpol</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">forward_sens</span><span class="p">(</span><span class="n">inputs_interpol</span><span class="p">)</span>
            <span class="n">grads</span> <span class="o">=</span> <span class="n">_comp_grad_sens</span><span class="p">(</span><span class="n">inputs_interpol</span><span class="p">,</span> <span class="n">pred_interpol</span><span class="p">,</span> <span class="n">pred_type</span><span class="p">,</span> <span class="n">ensemble</span><span class="p">)</span>
            <span class="n">gradients_mean</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">grads</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="n">pred_type</span> <span class="o">==</span> <span class="s1">&#39;Mean_Var&#39;</span> <span class="ow">or</span> <span class="n">ensemble</span> <span class="k">else</span> <span class="n">grads</span>
            <span class="k">if</span> <span class="n">pred_type</span> <span class="o">==</span> <span class="s1">&#39;Mean_Var&#39;</span> <span class="ow">or</span> <span class="n">ensemble</span><span class="p">:</span>
                <span class="n">gradients_var</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">grads</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        
        <span class="n">grads</span> <span class="o">=</span> <span class="n">_comp_grad_sens</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="n">pred</span><span class="p">,</span> <span class="n">pred_type</span><span class="p">,</span> <span class="n">ensemble</span><span class="p">)</span>
        <span class="n">gradients_mean</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">grads</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="n">pred_type</span> <span class="o">==</span> <span class="s1">&#39;Mean_Var&#39;</span> <span class="ow">or</span> <span class="n">ensemble</span> <span class="k">else</span> <span class="n">grads</span>
        <span class="n">ig_mean</span> <span class="o">=</span> <span class="p">(</span><span class="n">gradients_mean</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">gradients_mean</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span> <span class="o">/</span> <span class="mf">2.0</span> <span class="c1"># trapezoidal integration rule</span>
        <span class="n">ig_mean</span> <span class="o">=</span> <span class="n">ig_mean</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">*</span> <span class="n">difference_inp</span>
        <span class="c1"># print(gradients_mean[:,0,0,50]) # check how gradients evolve along the path</span>

        <span class="k">if</span> <span class="n">pred_type</span> <span class="o">==</span> <span class="s1">&#39;Mean_Var&#39;</span> <span class="ow">or</span> <span class="n">ensemble</span><span class="p">:</span>
            <span class="n">gradients_var</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">grads</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">ig_var</span> <span class="o">=</span> <span class="p">(</span><span class="n">gradients_var</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">gradients_var</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span> <span class="o">/</span> <span class="mf">2.0</span>
            <span class="n">ig_var</span> <span class="o">=</span> <span class="n">ig_var</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">*</span> <span class="n">difference_inp</span>
            <span class="k">return</span> <span class="n">ig_mean</span><span class="p">,</span> <span class="n">ig_var</span>
        <span class="k">return</span> <span class="n">ig_mean</span> <span class="c1"># shape [batch_size*forecast, pred_size, flatten_size]</span>
    <span class="k">return</span> <span class="n">integrated_grads</span><span class="p">(</span><span class="n">alphas</span><span class="p">,</span> <span class="n">baseline_inp</span><span class="p">,</span> <span class="n">difference_inp</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_reshape_array</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">array</span><span class="p">,</span> <span class="n">aggregation</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">remove_nans</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">repeat</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">repeat_size</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Reshape a post-processed array of the sensitivity tensor for</span>
<span class="sd">        further analysis, while keeping the information of possibly</span>
<span class="sd">        different window sizes between input and recurrent signals</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    model : Model consisting of nn.Modules</span>
<span class="sd">    array : np.ndarray</span>
<span class="sd">        Post-processed array of the sensitivity tensor</span>
<span class="sd">    aggregation : str, optional</span>
<span class="sd">        Specifies the aggregation method for the reshaped array, performed</span>
<span class="sd">        on its last axis. Choose from: mean, sum, rms.</span>
<span class="sd">        The default is None, i.e. only reshaping and hstacking is performed.</span>
<span class="sd">    remove_nans : bool, optional</span>
<span class="sd">        If True, NaN values are removed from the reshaped array. The default is False.</span>
<span class="sd">    repeat : bool, optional</span>
<span class="sd">        If True, the array is repeated after the aggregation (only if 1D!)</span>
<span class="sd">        for each input and recurrent channel. The default is False.</span>
<span class="sd">    repeat_size : int, optional</span>
<span class="sd">        Size of the repetition, which is the same for every channel. The default is None.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    np.ndarray</span>
<span class="sd">        Reshaped and hstacked array of the sensitivity tensor.</span>
<span class="sd">    </span>
<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        If an invalid aggregation method is given.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">m_type</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">Type</span>
    <span class="n">win_size</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">window_size</span><span class="p">,</span> <span class="n">model</span><span class="o">.</span><span class="n">rnn_window</span><span class="p">)</span> <span class="k">if</span> <span class="n">m_type</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;AR&#39;</span><span class="p">,</span> <span class="s1">&#39;AR_RNN&#39;</span><span class="p">]</span> <span class="k">else</span> <span class="n">model</span><span class="o">.</span><span class="n">window_size</span>
    <span class="n">ch_size</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">input_channels</span> <span class="o">+</span> <span class="n">model</span><span class="o">.</span><span class="n">pred_size</span> <span class="k">if</span> <span class="n">m_type</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;AR&#39;</span><span class="p">,</span> <span class="s1">&#39;AR_RNN&#39;</span><span class="p">]</span> <span class="k">else</span> <span class="n">model</span><span class="o">.</span><span class="n">input_channels</span>
    <span class="n">rec_start_idx</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">input_channels</span><span class="o">*</span><span class="n">model</span><span class="o">.</span><span class="n">window_size</span>

    <span class="c1"># Reshape the array such that the input and recurrent signals with their corresponding window sizes are separated</span>
    <span class="k">if</span> <span class="n">array</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">temp1</span> <span class="o">=</span> <span class="n">array</span><span class="p">[:</span><span class="n">rec_start_idx</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">input_channels</span><span class="p">,</span> <span class="n">model</span><span class="o">.</span><span class="n">window_size</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">m_type</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;AR&#39;</span><span class="p">,</span> <span class="s1">&#39;AR_RNN&#39;</span><span class="p">]:</span>
            <span class="n">temp2</span> <span class="o">=</span> <span class="n">array</span><span class="p">[</span><span class="n">rec_start_idx</span><span class="p">:]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">pred_size</span><span class="p">,</span> <span class="n">model</span><span class="o">.</span><span class="n">rnn_window</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">array</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">temp1</span> <span class="o">=</span> <span class="n">array</span><span class="p">[:,</span> <span class="p">:</span><span class="n">rec_start_idx</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">model</span><span class="o">.</span><span class="n">input_channels</span><span class="p">,</span> <span class="n">model</span><span class="o">.</span><span class="n">window_size</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">m_type</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;AR&#39;</span><span class="p">,</span> <span class="s1">&#39;AR_RNN&#39;</span><span class="p">]:</span>
            <span class="n">temp2</span> <span class="o">=</span> <span class="n">array</span><span class="p">[:,</span> <span class="n">rec_start_idx</span><span class="p">:]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">model</span><span class="o">.</span><span class="n">pred_size</span><span class="p">,</span> <span class="n">model</span><span class="o">.</span><span class="n">rnn_window</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">array</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
        <span class="n">temp1</span> <span class="o">=</span> <span class="n">array</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:</span><span class="n">rec_start_idx</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">*</span><span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">2</span><span class="p">],</span> <span class="n">model</span><span class="o">.</span><span class="n">input_channels</span><span class="p">,</span> <span class="n">model</span><span class="o">.</span><span class="n">window_size</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">m_type</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;AR&#39;</span><span class="p">,</span> <span class="s1">&#39;AR_RNN&#39;</span><span class="p">]:</span>
            <span class="n">temp2</span> <span class="o">=</span> <span class="n">array</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">rec_start_idx</span><span class="p">:]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">*</span><span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">2</span><span class="p">],</span> <span class="n">model</span><span class="o">.</span><span class="n">pred_size</span><span class="p">,</span> <span class="n">model</span><span class="o">.</span><span class="n">rnn_window</span><span class="p">)</span>

    <span class="c1"># Apply aggregation method if specified, otherwise only stack arrays together</span>
    <span class="k">if</span> <span class="n">aggregation</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">temp1</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">temp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">ch_size</span><span class="p">,</span> <span class="n">win_size</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
            <span class="n">temp</span><span class="p">[:</span><span class="n">model</span><span class="o">.</span><span class="n">input_channels</span><span class="p">,</span> <span class="o">-</span><span class="n">model</span><span class="o">.</span><span class="n">window_size</span><span class="p">:]</span> <span class="o">=</span> <span class="n">temp1</span> <span class="c1"># right-align all input channels</span>
            <span class="k">if</span> <span class="n">m_type</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;AR&#39;</span><span class="p">,</span> <span class="s1">&#39;AR_RNN&#39;</span><span class="p">]:</span>
                <span class="n">temp</span><span class="p">[</span><span class="n">model</span><span class="o">.</span><span class="n">input_channels</span><span class="p">:,</span> <span class="o">-</span><span class="n">model</span><span class="o">.</span><span class="n">rnn_window</span><span class="p">:]</span> <span class="o">=</span> <span class="n">temp2</span> <span class="c1"># right-align all recurrent channels</span>
        <span class="k">elif</span> <span class="n">temp1</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">temp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ch_size</span><span class="p">,</span> <span class="n">win_size</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
            <span class="n">temp</span><span class="p">[:,</span> <span class="p">:</span><span class="n">model</span><span class="o">.</span><span class="n">input_channels</span><span class="p">,</span> <span class="o">-</span><span class="n">model</span><span class="o">.</span><span class="n">window_size</span><span class="p">:]</span> <span class="o">=</span> <span class="n">temp1</span>
            <span class="k">if</span> <span class="n">m_type</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;AR&#39;</span><span class="p">,</span> <span class="s1">&#39;AR_RNN&#39;</span><span class="p">]:</span>
                <span class="n">temp</span><span class="p">[:,</span> <span class="n">model</span><span class="o">.</span><span class="n">input_channels</span><span class="p">:,</span> <span class="o">-</span><span class="n">model</span><span class="o">.</span><span class="n">rnn_window</span><span class="p">:]</span> <span class="o">=</span> <span class="n">temp2</span>
        <span class="k">if</span> <span class="n">remove_nans</span><span class="p">:</span>
            <span class="n">temp</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">x</span><span class="p">)]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">temp</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">temp1</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="n">inp_ch_lst</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="n">model</span><span class="o">.</span><span class="n">window_size</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">model</span><span class="o">.</span><span class="n">input_channels</span><span class="p">)]</span>
                <span class="k">if</span> <span class="n">m_type</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;AR&#39;</span><span class="p">,</span> <span class="s1">&#39;AR_RNN&#39;</span><span class="p">]:</span>
                    <span class="n">rec_ch_lst</span> <span class="o">=</span> <span class="p">[</span><span class="n">rec_start_idx</span> <span class="o">+</span> <span class="n">i</span><span class="o">*</span><span class="n">model</span><span class="o">.</span><span class="n">rnn_window</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">pred_size</span><span class="p">)]</span>
                    <span class="n">temp</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">inp_ch_lst</span> <span class="o">+</span> <span class="n">rec_ch_lst</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">temp</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">temp</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">inp_ch_lst</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">temp</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">temp</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">aggregation</span> <span class="o">==</span> <span class="s1">&#39;mean&#39;</span><span class="p">:</span>
            <span class="n">agg1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">temp1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">m_type</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;AR&#39;</span><span class="p">,</span> <span class="s1">&#39;AR_RNN&#39;</span><span class="p">]:</span>
                <span class="n">agg2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">temp2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">aggregation</span> <span class="o">==</span> <span class="s1">&#39;median&#39;</span><span class="p">:</span>
            <span class="n">agg1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">temp1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">m_type</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;AR&#39;</span><span class="p">,</span> <span class="s1">&#39;AR_RNN&#39;</span><span class="p">]:</span>
                <span class="n">agg2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">temp2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">aggregation</span> <span class="o">==</span> <span class="s1">&#39;sum&#39;</span><span class="p">:</span>
            <span class="n">agg1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">temp1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">m_type</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;AR&#39;</span><span class="p">,</span> <span class="s1">&#39;AR_RNN&#39;</span><span class="p">]:</span>
                <span class="n">agg2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">temp2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">aggregation</span> <span class="o">==</span> <span class="s1">&#39;rms&#39;</span><span class="p">:</span>
            <span class="n">agg1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">temp1</span><span class="p">),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">m_type</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;AR&#39;</span><span class="p">,</span> <span class="s1">&#39;AR_RNN&#39;</span><span class="p">]:</span>
                <span class="n">agg2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">temp2</span><span class="p">),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Invalid aggregation method &quot;</span><span class="si">{</span><span class="n">aggregation</span><span class="si">}</span><span class="s1">&quot; given! Choose from: mean, sum, rms.&#39;</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">agg1</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">repeat</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">repeat_size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">agg1</span> <span class="o">=</span> <span class="n">agg1</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">window_size</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">m_type</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;AR&#39;</span><span class="p">,</span> <span class="s1">&#39;AR_RNN&#39;</span><span class="p">]:</span>
                    <span class="n">agg2</span> <span class="o">=</span> <span class="n">agg2</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">rnn_window</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">agg1</span> <span class="o">=</span> <span class="n">agg1</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">repeat_size</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">m_type</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;AR&#39;</span><span class="p">,</span> <span class="s1">&#39;AR_RNN&#39;</span><span class="p">]:</span>
                    <span class="n">agg2</span> <span class="o">=</span> <span class="n">agg2</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">repeat_size</span><span class="p">)</span>
            
            <span class="k">if</span> <span class="n">m_type</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;AR&#39;</span><span class="p">,</span> <span class="s1">&#39;AR_RNN&#39;</span><span class="p">]:</span>
                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">agg1</span><span class="p">),</span> <span class="n">agg2</span><span class="p">),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">agg1</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">m_type</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;AR&#39;</span><span class="p">,</span> <span class="s1">&#39;AR_RNN&#39;</span><span class="p">]:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">agg1</span><span class="p">,</span> <span class="n">agg2</span><span class="p">),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">agg1</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_postprocess_sens</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">sensitivity</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Postprocess the sensitivity tensor to get information about mean and std of the gradients,</span>
<span class="sd">    aggregated over the timesteps, output channels and window sizes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    model : Model consisting of nn.Modules</span>
<span class="sd">    sensitivity : torch.Tensor</span>
<span class="sd">        Sensitivity tensor that contains the gradients of the output with respect to the inputs,</span>
<span class="sd">        with shape=[len(data_loader), pred_size, input_channels*window_size + pred_size*rnn_window]</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    sum_mean_feature : np.ndarray</span>
<span class="sd">        RMS of the time-averaged sensitivities over all output channels for each input feature</span>
<span class="sd">    sum_std_feature : np.ndarray</span>
<span class="sd">        Sum of the std of the sensitivities over all output channels for each input feature</span>
<span class="sd">    sum_inp_channels : np.ndarray</span>
<span class="sd">        RMS of the time-avg. sensitivities for each input-output channel combination</span>
<span class="sd">    std_inp_channels : np.ndarray</span>
<span class="sd">        Sum of the std of the sensitivities for each input-output channel combination</span>
<span class="sd">    rms_out_ch_sens : np.ndarray</span>
<span class="sd">        RMS of the sensitivities over all output channels for each timestep and input feature</span>
<span class="sd">    mean_out_ch_sens : np.ndarray</span>
<span class="sd">        Mean of the sensitivities over all output channels for each timestep and input feature</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">sensitivity</span> <span class="o">=</span> <span class="n">sensitivity</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>

    <span class="c1"># Compute the RMS across/over all output channels for each timestep</span>
    <span class="n">rms_out_ch_sens</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">sensitivity</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span> <span class="c1"># shape [len(dataloader), input_channels*window_size + pred_size*rnn_window]</span>
    <span class="n">mean_out_ch_sens</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">sensitivity</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># Compute the mean and var of the sensitivity tensor along the time axis</span>
    <span class="n">temp_mean_sens</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">sensitivity</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="c1"># shape [pred_size, input_channels*window_size + pred_size*rnn_window]</span>
    <span class="n">temp_std_sens</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">sensitivity</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="c1"># Compute mean-squared sensitivity (RMS) and mean-squared std.-dev. across all output channels</span>
    <span class="n">sum_mean_feature</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">temp_mean_sens</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span> <span class="c1"># shape [input_channels*window_size + pred_size*rnn_window]</span>
    <span class="n">sum_std_feature</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">temp_std_sens</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">temp_mean_sens</span> <span class="o">-</span> <span class="n">temp_mean_sens</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>

    <span class="c1"># Compute the RMS across entire window size for each input/recurrent-output channel combination</span>
    <span class="n">sum_inp_channels</span> <span class="o">=</span> <span class="n">_reshape_array</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">temp_mean_sens</span><span class="p">,</span> <span class="n">aggregation</span><span class="o">=</span><span class="s1">&#39;rms&#39;</span><span class="p">)</span> <span class="c1"># shape [pred_size, input_channels+pred_size]</span>
    <span class="n">std_inp_channels</span> <span class="o">=</span> <span class="n">_reshape_array</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">temp_std_sens</span><span class="p">,</span> <span class="n">aggregation</span><span class="o">=</span><span class="s1">&#39;rms&#39;</span><span class="p">)</span>

    <span class="c1"># Delete sensitivity tensor for less memory usage</span>
    <span class="k">del</span> <span class="n">sensitivity</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">sum_mean_feature</span><span class="p">,</span> <span class="n">sum_std_feature</span><span class="p">),</span> <span class="p">(</span><span class="n">sum_inp_channels</span><span class="p">,</span> <span class="n">std_inp_channels</span><span class="p">),</span> <span class="p">(</span><span class="n">rms_out_ch_sens</span><span class="p">,</span> <span class="n">mean_out_ch_sens</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_pred_ARNN_batch</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">batch_sw</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="s1">&#39;cpu&#39;</span><span class="p">,</span> <span class="n">sens_params</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Predict function for forward ARNN models with batched dataset for faster</span>
<span class="sd">    computation.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    model : Model consisting of nn.Modules</span>
<span class="sd">    batch_sw : Batched Sliding Window</span>
<span class="sd">        Dataset to compute output for</span>
<span class="sd">    device : str, optional</span>
<span class="sd">        device to compute on. The default is &#39;cpu&#39;.</span>
<span class="sd">    sens_params : dict, optional</span>
<span class="sd">        Dictionary containing the parameters for sensitivity analysis.</span>
<span class="sd">        Key &#39;method&#39; defines the method for sensitivity analysis: &#39;gradient&#39; or &#39;perturbation&#39;.</span>
<span class="sd">        Key &#39;comp&#39; defines whether gradients are computed for sensitivity analysis.</span>
<span class="sd">        Key &#39;plot&#39; defines whether the results of the sensitivity analysis are visualized.</span>
<span class="sd">        Key &#39;sens_length&#39; defines the number of randomly sampled subset of timesteps for the analysis.</span>
<span class="sd">        (If not a multiple of the model&#39;s forecast, the number will be rounded up to the next multiple.)</span>
<span class="sd">        The default is None, i.e. no sensitivity analysis is performed.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    if comp_sens is False:</span>
<span class="sd">        torch.Tensor : Tensor of same langth as input, containing the predictions.</span>
<span class="sd">    if comp_sens is True:</span>
<span class="sd">        (torch.Tensor, dict) : Tuple of Tensor of same length as input and sensitivity dict.</span>
<span class="sd">        Key is the prediction type, value is the sensitivity tensor.</span>
<span class="sd">    if comp_sens is True and random_samples &gt; 0:</span>
<span class="sd">        (torch.Tensor, dict, torch.Tensor, torch.Tensor) : Tuple of Tensor of same length as input,</span>
<span class="sd">        sensitivity dict, uncertainty quantification tensor and random samples tensor.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">size</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">window_size</span><span class="p">,</span> <span class="n">model</span><span class="o">.</span><span class="n">rnn_window</span><span class="p">)</span>
    <span class="n">forecast</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">forecast</span>
    <span class="n">rnn_size</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">rnn_window</span>
    <span class="n">w</span> <span class="o">=</span> <span class="n">batch_sw</span><span class="o">.</span><span class="n">__widths__</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">pred_warmup</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">w</span><span class="p">,</span> <span class="n">model</span><span class="o">.</span><span class="n">pred_size</span><span class="p">,</span> <span class="n">size</span><span class="p">))</span>
    <span class="n">prediction</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">w</span><span class="p">,</span> <span class="n">model</span><span class="o">.</span><span class="n">pred_size</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">batch_sw</span><span class="p">)</span><span class="o">*</span><span class="n">forecast</span><span class="p">),</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;nan&#39;</span><span class="p">))</span>
    <span class="n">prediction</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">((</span><span class="n">pred_warmup</span><span class="p">,</span> <span class="n">prediction</span><span class="p">),</span> <span class="n">dim</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">model</span><span class="o">.</span><span class="n">Pred_Type</span> <span class="o">==</span> <span class="s1">&#39;Mean_Var&#39;</span><span class="p">:</span>
        <span class="n">var_prediction</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">prediction</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

    <span class="n">original_out</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">w</span><span class="p">,</span> <span class="n">model</span><span class="o">.</span><span class="n">pred_size</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">batch_sw</span><span class="p">)</span><span class="o">*</span><span class="n">forecast</span><span class="p">),</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;nan&#39;</span><span class="p">))</span>

    <span class="c1"># Tensors to device</span>
    <span class="n">prediction</span> <span class="o">=</span> <span class="n">prediction</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>
    <span class="n">original_out</span> <span class="o">=</span> <span class="n">original_out</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>
    <span class="n">model</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>

    <span class="n">checks</span> <span class="o">=</span> <span class="n">_check_sens_params_pred</span><span class="p">(</span><span class="n">sens_params</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">sens_params</span><span class="p">:</span>
        <span class="n">method</span><span class="p">,</span> <span class="n">comp_sens</span><span class="p">,</span> <span class="n">verbose</span><span class="p">,</span> <span class="n">sens_length</span><span class="p">,</span> <span class="n">num_samples</span><span class="p">,</span> <span class="n">std_dev</span><span class="p">,</span> <span class="n">correlated</span><span class="p">,</span> <span class="n">random_samples</span><span class="p">,</span> <span class="n">amplification</span> <span class="o">=</span> <span class="n">checks</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">comp_sens</span><span class="p">,</span> <span class="n">verbose</span> <span class="o">=</span> <span class="n">checks</span> <span class="c1"># False</span>

    <span class="c1"># Initialise 3D tensor for sensitivity analysis</span>
    <span class="k">if</span> <span class="n">comp_sens</span><span class="p">:</span>
        <span class="n">flatten_size</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">window_size</span><span class="o">*</span><span class="n">model</span><span class="o">.</span><span class="n">input_channels</span> <span class="o">+</span> <span class="n">model</span><span class="o">.</span><span class="n">rnn_window</span><span class="o">*</span><span class="n">model</span><span class="o">.</span><span class="n">pred_size</span>
        <span class="n">num_timesteps</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">batch_sw</span><span class="p">)</span><span class="o">*</span><span class="n">forecast</span>
        <span class="n">sens_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">batch_sw</span><span class="p">))</span>
        <span class="n">sens_uq</span><span class="p">,</span> <span class="n">eps</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">sens_length</span><span class="p">:</span>
            <span class="n">num_timesteps</span><span class="p">,</span> <span class="n">sens_indices</span> <span class="o">=</span> <span class="n">_random_subset_sens_indices</span><span class="p">(</span><span class="n">sens_length</span><span class="p">,</span> <span class="n">forecast</span><span class="p">,</span>
                                                            <span class="n">model</span><span class="o">.</span><span class="n">Type</span><span class="p">,</span> <span class="n">batch_sw</span><span class="p">,</span> <span class="n">batched</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">sens_mean</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">w</span><span class="p">,</span> <span class="n">num_timesteps</span><span class="p">,</span> <span class="n">model</span><span class="o">.</span><span class="n">pred_size</span><span class="p">,</span> <span class="n">flatten_size</span><span class="p">),</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;nan&#39;</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">model</span><span class="o">.</span><span class="n">Pred_Type</span> <span class="o">==</span> <span class="s2">&quot;Mean_Var&quot;</span><span class="p">:</span>
            <span class="n">sens_var</span> <span class="o">=</span> <span class="n">sens_mean</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">random_samples</span><span class="p">:</span>
                <span class="n">sens_uq</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">num_timesteps</span><span class="p">,</span> <span class="n">random_samples</span><span class="p">,</span> <span class="n">model</span><span class="o">.</span><span class="n">pred_size</span><span class="p">,</span> <span class="n">flatten_size</span><span class="p">),</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;nan&#39;</span><span class="p">))</span>
                <span class="n">eps</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">num_timesteps</span><span class="p">,</span> <span class="n">random_samples</span><span class="p">,</span> <span class="n">model</span><span class="o">.</span><span class="n">pred_size</span><span class="p">),</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;nan&#39;</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Start </span><span class="si">{</span><span class="n">method</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span><span class="si">}</span><span class="s1">-based Sensitivity Analysis...</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Shape of sensitivity tensor: </span><span class="si">{</span><span class="n">sens_mean</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

    <span class="c1"># Iterate over dataloader</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">batch_sw</span><span class="p">)))</span> <span class="k">if</span> <span class="n">verbose</span> <span class="k">else</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">batch_sw</span><span class="p">)):</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="n">i</span><span class="o">*</span><span class="n">forecast</span> <span class="o">+</span> <span class="n">size</span>
        <span class="n">inputs</span><span class="p">,</span> <span class="n">output</span> <span class="o">=</span> <span class="n">batch_sw</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">inputs</span><span class="p">,</span> <span class="n">output</span> <span class="o">=</span> <span class="n">inputs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">),</span> <span class="n">output</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>
        <span class="n">original_out</span><span class="p">[:</span><span class="n">batch_sw</span><span class="o">.</span><span class="n">valid_sws</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="p">:,</span>
                     <span class="n">i</span><span class="o">*</span><span class="n">forecast</span><span class="p">:(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">forecast</span><span class="p">]</span> <span class="o">=</span> <span class="n">output</span>
        <span class="n">x_rec</span> <span class="o">=</span> <span class="n">prediction</span><span class="p">[:</span><span class="n">batch_sw</span><span class="o">.</span><span class="n">valid_sws</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="p">:,</span>
                           <span class="p">(</span><span class="n">offset</span> <span class="o">-</span> <span class="n">rnn_size</span><span class="p">):</span><span class="n">offset</span><span class="p">]</span>
        
        <span class="c1"># Prepare input for model to allow autograd computing gradients of outputs w.r.t. inputs</span>
        <span class="n">inputs</span> <span class="o">=</span> <span class="n">Variable</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="n">start_dim</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="n">requires_grad</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">x_rec</span> <span class="o">=</span> <span class="n">Variable</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">x_rec</span><span class="p">,</span> <span class="n">start_dim</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="n">requires_grad</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">inp</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">((</span><span class="n">inputs</span><span class="p">,</span> <span class="n">x_rec</span><span class="p">),</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">pred</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">forward_sens</span><span class="p">(</span><span class="n">inp</span><span class="p">)</span> <span class="k">if</span> <span class="n">comp_sens</span> <span class="k">else</span> <span class="n">model</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="n">x_rec</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">comp_sens</span> <span class="ow">and</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">sens_indices</span><span class="p">:</span>
            <span class="n">sens_temp</span> <span class="o">=</span> <span class="n">_comp_sensitivity</span><span class="p">(</span><span class="n">method</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">inp</span><span class="p">,</span> <span class="n">pred</span><span class="p">,</span> <span class="n">num_samples</span><span class="p">,</span> <span class="n">std_dev</span><span class="p">,</span> <span class="n">correlated</span><span class="p">,</span> <span class="n">random_samples</span><span class="p">,</span> <span class="n">amplification</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">model</span><span class="o">.</span><span class="n">Pred_Type</span> <span class="o">==</span> <span class="s2">&quot;Mean_Var&quot;</span><span class="p">:</span>
                <span class="n">sens_mean</span><span class="p">[:</span><span class="n">batch_sw</span><span class="o">.</span><span class="n">valid_sws</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">idx</span><span class="p">:</span><span class="n">idx</span><span class="o">+</span><span class="n">forecast</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">sens_temp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">batch_sw</span><span class="o">.</span><span class="n">valid_sws</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">forecast</span><span class="p">,</span> <span class="n">model</span><span class="o">.</span><span class="n">pred_size</span><span class="p">,</span> <span class="n">flatten_size</span><span class="p">)</span>
                <span class="n">sens_var</span><span class="p">[:</span><span class="n">batch_sw</span><span class="o">.</span><span class="n">valid_sws</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">idx</span><span class="p">:</span><span class="n">idx</span><span class="o">+</span><span class="n">forecast</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">sens_temp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">batch_sw</span><span class="o">.</span><span class="n">valid_sws</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">forecast</span><span class="p">,</span> <span class="n">model</span><span class="o">.</span><span class="n">pred_size</span><span class="p">,</span> <span class="n">flatten_size</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">random_samples</span><span class="p">:</span>
                    <span class="n">sens_uq</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">eps</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">sens_temp</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">sens_temp</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">sens_mean</span><span class="p">[:</span><span class="n">batch_sw</span><span class="o">.</span><span class="n">valid_sws</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">idx</span><span class="p">:</span><span class="n">idx</span><span class="o">+</span><span class="n">forecast</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">sens_temp</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">batch_sw</span><span class="o">.</span><span class="n">valid_sws</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">forecast</span><span class="p">,</span> <span class="n">model</span><span class="o">.</span><span class="n">pred_size</span><span class="p">,</span> <span class="n">flatten_size</span><span class="p">)</span>
            <span class="n">idx</span> <span class="o">+=</span> <span class="n">forecast</span>
        
        <span class="k">if</span> <span class="n">model</span><span class="o">.</span><span class="n">Pred_Type</span> <span class="o">==</span> <span class="s1">&#39;Mean_Var&#39;</span><span class="p">:</span>
            <span class="n">prediction</span><span class="p">[:</span><span class="n">batch_sw</span><span class="o">.</span><span class="n">valid_sws</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="p">:,</span>
                       <span class="n">i</span><span class="o">*</span><span class="n">forecast</span><span class="o">+</span><span class="n">size</span><span class="p">:(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">forecast</span><span class="o">+</span><span class="n">size</span><span class="p">]</span> <span class="o">=</span> <span class="n">pred</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span>
            <span class="n">var_prediction</span><span class="p">[:</span><span class="n">batch_sw</span><span class="o">.</span><span class="n">valid_sws</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="p">:,</span>
                           <span class="n">i</span><span class="o">*</span><span class="n">forecast</span><span class="o">+</span><span class="n">size</span><span class="p">:(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">forecast</span><span class="o">+</span><span class="n">size</span><span class="p">]</span> <span class="o">=</span> <span class="n">pred</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">prediction</span><span class="p">[:</span><span class="n">batch_sw</span><span class="o">.</span><span class="n">valid_sws</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="p">:,</span>
                       <span class="n">i</span><span class="o">*</span><span class="n">forecast</span><span class="o">+</span><span class="n">size</span><span class="p">:(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">forecast</span><span class="o">+</span><span class="n">size</span><span class="p">]</span> <span class="o">=</span> <span class="n">pred</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span>
    
    <span class="c1"># cut zeros from initialisation</span>
    <span class="n">prediction</span> <span class="o">=</span> <span class="n">prediction</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">size</span><span class="p">:]</span>

    <span class="k">if</span> <span class="n">model</span><span class="o">.</span><span class="n">Pred_Type</span> <span class="o">==</span> <span class="s1">&#39;Mean_Var&#39;</span><span class="p">:</span>
        <span class="n">var_prediction</span> <span class="o">=</span> <span class="n">var_prediction</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">size</span><span class="p">:]</span>
        <span class="n">prediction</span> <span class="o">=</span> <span class="p">(</span><span class="n">prediction</span><span class="o">.</span><span class="n">cpu</span><span class="p">(),</span> <span class="n">var_prediction</span><span class="o">.</span><span class="n">cpu</span><span class="p">())</span>
    
    <span class="k">if</span> <span class="n">comp_sens</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">model</span><span class="o">.</span><span class="n">Pred_Type</span> <span class="o">==</span> <span class="s1">&#39;Mean_Var&#39;</span><span class="p">:</span>
            <span class="n">sensitivities</span> <span class="o">=</span> <span class="p">(</span><span class="n">sens_mean</span><span class="o">.</span><span class="n">cpu</span><span class="p">(),</span> <span class="n">sens_var</span><span class="o">.</span><span class="n">cpu</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sensitivities</span> <span class="o">=</span> <span class="n">sens_mean</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="se">\n</span><span class="si">{</span><span class="n">method</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span><span class="si">}</span><span class="s1">-based Sensitivity Analysis completed!</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">random_samples</span><span class="p">:</span> <span class="c1"># cut all lines that contain NaNs and flatten first two dimensions</span>
            <span class="n">sens_uq</span><span class="p">,</span> <span class="n">eps</span> <span class="o">=</span> <span class="n">sens_uq</span><span class="o">.</span><span class="n">cpu</span><span class="p">(),</span> <span class="n">eps</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span>
            <span class="n">sens_uq</span> <span class="o">=</span> <span class="n">sens_uq</span><span class="p">[</span><span class="o">~</span><span class="n">torch</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">sens_uq</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">))]</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">start_dim</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">end_dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">eps</span> <span class="o">=</span> <span class="n">eps</span><span class="p">[</span><span class="o">~</span><span class="n">torch</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">eps</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">))]</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">start_dim</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">end_dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">prediction</span><span class="p">,</span> <span class="n">sensitivities</span><span class="p">,</span> <span class="n">sens_uq</span><span class="p">,</span> <span class="n">eps</span>
        <span class="c1"># return prediction, sensitivities</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">prediction</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_predict_arnn_uncertainty</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">dataloader</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="s1">&#39;cpu&#39;</span><span class="p">,</span> <span class="n">sens_params</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Predict function for ARNN models that support uncertainty estimation</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    model : Model consisting of nn.Modules</span>
<span class="sd">    dataloader : Dataloader</span>
<span class="sd">        Dataloader to predict output</span>
<span class="sd">    device : str, optional</span>
<span class="sd">        device to compute on. The default is &#39;cpu&#39;.</span>
<span class="sd">    sens_params : dict, optional</span>
<span class="sd">        Dictionary that contains the parameters for the sensitivity analysis.</span>
<span class="sd">        Key &#39;method&#39; defines the method for sensitivity analysis: &#39;gradient&#39; or &#39;perturbation&#39;.</span>
<span class="sd">        Key &#39;comp&#39; defines whether gradients are computed for sensitivity analysis.</span>
<span class="sd">        Key &#39;plot&#39; defines whether the results of the sensitivity analysis are visualized.</span>
<span class="sd">        Key &#39;sens_length&#39; defines the number of randomly sampled subset of timesteps for the analysis.</span>
<span class="sd">        The default is None, i.e. no sensitivity analysis is computed.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    if comp_sens is False:</span>
<span class="sd">        torch.Tensor : Tensor of same langth as input, containing the predictions.</span>
<span class="sd">        if comp_sens is True:</span>
<span class="sd">            (torch.Tensor, dict) : Tuple of Tensor of same length as input and sensitivity dict.</span>
<span class="sd">            Key is the prediction type, value is the sensitivity tensor.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_prediction</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">dataloader</span><span class="p">,</span> <span class="n">device</span><span class="p">,</span> <span class="n">sens_params</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_predict_arnn_uncertainty_both</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">dataloader</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="s1">&#39;cpu&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Predict function for ARNN models that support uncertainty estimation</span>
<span class="sd">    and capture heteroscedastic and aleatoric uncertainty</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    model : Model consisting of nn.Modules</span>
<span class="sd">    dataloader : Dataloader</span>
<span class="sd">        Dataloader to predict output</span>
<span class="sd">    device : str, optional</span>
<span class="sd">        device to compute on. The default is &#39;cpu&#39;.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    if comp_sens is False:</span>
<span class="sd">        torch.Tensor : Tensor of same langth as input, containing the predictions.</span>
<span class="sd">        if comp_sens is True:</span>
<span class="sd">            (torch.Tensor, dict) : Tuple of Tensor of same length as input and sensitivity dict.</span>
<span class="sd">            Key is the prediction type, value is the sensitivity tensor.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_prediction</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">dataloader</span><span class="p">,</span> <span class="n">device</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_async_prediction</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">dataloader</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="s1">&#39;cpu&#39;</span><span class="p">,</span> <span class="n">n_samples</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">reduce</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">ensemble_weights</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sens_params</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Prediction of a whole Time Series with a model wrapper</span>
<span class="sd">    in case of MVE ensemble, the weighting is done due to</span>
<span class="sd">    https://arxiv.org/pdf/1612.01474.pdf</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    dataloader : Dataloader</span>
<span class="sd">        Dataloader to predict output</span>
<span class="sd">    device : str, optional</span>
<span class="sd">        device to compute on. The default is &#39;cpu&#39;.</span>
<span class="sd">    n_samples : int</span>
<span class="sd">        Numbers of samples to take for Monte Carlo estimation. The default is 1.</span>
<span class="sd">    reduce: bool, optional</span>
<span class="sd">        Whether the combined uncertainty (True) or both uncertainties should be returned. The default is True.</span>
<span class="sd">    ensemble_weights: list[dict]</span>
<span class="sd">        List of torch state dicts containing weights. The default is None</span>
<span class="sd">    sens_params : dict, optional</span>
<span class="sd">        Dictionary that contains the parameters for the sensitivity analysis.</span>
<span class="sd">        Key &#39;method&#39; defines the method for sensitivity analysis: &#39;gradient&#39; or &#39;perturbation&#39;.</span>
<span class="sd">        Key &#39;comp&#39; defines whether gradients are computed for sensitivity analysis.</span>
<span class="sd">        Key &#39;plot&#39; defines whether the results of the sensitivity analysis are visualized.</span>
<span class="sd">        Key &#39;verbose&#39; defines whether the information about the sensitivity analysis is printed.</span>
<span class="sd">        Key &#39;sens_length&#39; defines the number of randomly sampled subset of timesteps for the analysis.</span>
<span class="sd">        The default is None, i.e. no sensitivity analysis is computed.</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    if comp_sens is False:</span>
<span class="sd">        torch.Tensor : Tensor of same langth as input, containing the predictions.</span>
<span class="sd">    if comp_sens is True:</span>
<span class="sd">        (torch.Tensor, dict) : Tuple of Tensor of same length as input and sensitivity dict.</span>
<span class="sd">        Key is the prediction type, value is the sensitivity tensor.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">model</span><span class="o">.</span><span class="n">eval</span><span class="p">()</span>
    <span class="n">prediction_type</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">Pred_Type</span>

    <span class="k">if</span> <span class="n">n_samples</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="c1"># Enable dropout Layers during test time</span>
        <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">model</span><span class="o">.</span><span class="n">modules</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">m</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;Dropout&#39;</span><span class="p">:</span>
                <span class="n">m</span><span class="o">.</span><span class="n">train</span><span class="p">()</span>
    
    <span class="n">checks</span> <span class="o">=</span> <span class="n">_check_sens_params_pred</span><span class="p">(</span><span class="n">sens_params</span><span class="p">)</span>
    <span class="n">comp_sens</span> <span class="o">=</span> <span class="n">checks</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="n">sens_params</span> <span class="k">else</span> <span class="kc">False</span> <span class="c1"># True if sens_params are given, False otherwise</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="n">checks</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="k">if</span> <span class="n">sens_params</span> <span class="k">else</span> <span class="kc">False</span>

    <span class="k">if</span> <span class="n">ensemble_weights</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">comp_sens</span><span class="p">:</span>
            <span class="n">predictions</span> <span class="o">=</span> <span class="p">[</span><span class="n">model</span><span class="o">.</span><span class="n">prediction</span><span class="p">(</span><span class="n">dataloader</span><span class="p">,</span> <span class="n">device</span><span class="p">,</span> <span class="n">sens_params</span><span class="o">=</span><span class="n">sens_params</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_samples</span><span class="p">)]</span>
            <span class="n">predictions</span><span class="p">,</span> <span class="n">sens_dicts</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">predictions</span><span class="p">)</span>
            <span class="n">predictions</span><span class="p">,</span> <span class="n">sens_dicts</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">predictions</span><span class="p">),</span> <span class="nb">list</span><span class="p">(</span><span class="n">sens_dicts</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">predictions</span> <span class="o">=</span> <span class="p">[</span><span class="n">model</span><span class="o">.</span><span class="n">prediction</span><span class="p">(</span><span class="n">dataloader</span><span class="p">,</span> <span class="n">device</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_samples</span><span class="p">)]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">predictions</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">sens_dicts</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">ensemble_weights</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_samples</span><span class="p">):</span>
                <span class="n">model</span><span class="o">.</span><span class="n">load_state_dict</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">comp_sens</span><span class="p">:</span>
                    <span class="n">pred</span><span class="p">,</span> <span class="n">sensitivity</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">prediction</span><span class="p">(</span><span class="n">dataloader</span><span class="p">,</span> <span class="n">device</span><span class="p">,</span> <span class="n">sens_params</span><span class="o">=</span><span class="n">sens_params</span><span class="p">)</span>
                    <span class="n">predictions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pred</span><span class="p">)</span>
                    <span class="n">sens_dicts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sensitivity</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">predictions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">prediction</span><span class="p">(</span><span class="n">dataloader</span><span class="p">,</span> <span class="n">device</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Shape of single prediction: </span><span class="si">{</span><span class="n">predictions</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="n">predictions</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">predictions</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Shape of ensemble predictions: </span><span class="si">{</span><span class="n">predictions</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">comp_sens</span><span class="p">:</span>
        <span class="n">mean_str</span> <span class="o">=</span> <span class="s1">&#39;Mean&#39;</span> <span class="k">if</span> <span class="n">prediction_type</span> <span class="o">==</span> <span class="s2">&quot;Mean_Var&quot;</span> <span class="k">else</span> <span class="s1">&#39;Point&#39;</span>
        <span class="n">means_senses</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">sens_dict</span><span class="p">[</span><span class="n">mean_str</span><span class="p">]</span> <span class="k">for</span> <span class="n">sens_dict</span> <span class="ow">in</span> <span class="n">sens_dicts</span><span class="p">])</span>
        <span class="n">mean_sens</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">means_senses</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">prediction_type</span> <span class="o">==</span> <span class="s2">&quot;Mean_Var&quot;</span><span class="p">:</span>
            <span class="n">var_sens</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">sens_dict</span><span class="p">[</span><span class="s1">&#39;Aleatoric_UQ&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">sens_dict</span> <span class="ow">in</span> <span class="n">sens_dicts</span><span class="p">])</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">var_sens</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">means_senses</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">sens_avg_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;Mean&#39;</span><span class="p">:</span> <span class="n">mean_sens</span><span class="p">,</span> <span class="s1">&#39;Var_UQ&#39;</span><span class="p">:</span> <span class="n">var_sens</span><span class="p">}</span>

    <span class="c1"># epistemic_var = torch.var(predictions[0], dim=0) if ensemble_weights is not None or n_samples &gt; 1 else torch.zeros(mean.shape)</span>

    <span class="k">if</span> <span class="n">prediction_type</span> <span class="o">==</span> <span class="s2">&quot;Mean_Var&quot;</span><span class="p">:</span>
        <span class="n">mean</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">predictions</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:],</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">total_var</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">predictions</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">+</span> <span class="n">predictions</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span><span class="o">.</span><span class="n">square</span><span class="p">(),</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">-</span> <span class="n">mean</span><span class="o">.</span><span class="n">square</span><span class="p">()</span>
        <span class="n">aleatoric_var</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">predictions</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:],</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">epistemic_var</span> <span class="o">=</span> <span class="n">total_var</span> <span class="o">-</span> <span class="n">aleatoric_var</span>
        <span class="n">predictions</span> <span class="o">=</span> <span class="p">(</span><span class="n">mean</span><span class="p">,</span> <span class="n">total_var</span><span class="p">)</span> <span class="k">if</span> <span class="n">reduce</span> <span class="k">else</span> <span class="p">(</span><span class="n">mean</span><span class="p">,</span> <span class="n">epistemic_var</span><span class="p">,</span> <span class="n">aleatoric_var</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">mean</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">predictions</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">epistemic_var</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">predictions</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="k">if</span> <span class="n">ensemble_weights</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">n_samples</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">mean</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">predictions</span> <span class="o">=</span> <span class="p">(</span><span class="n">mean</span><span class="p">,</span> <span class="n">epistemic_var</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">comp_sens</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">predictions</span><span class="p">,</span> <span class="n">sens_avg_dict</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">predictions</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_prediction</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">dataloader</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="s1">&#39;cpu&#39;</span><span class="p">,</span> <span class="n">sens_params</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Prediction of a whole Time Series</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    dataloader : Dataloader</span>
<span class="sd">        Dataloader to predict output</span>
<span class="sd">    device : str, optional</span>
<span class="sd">        device to compute on. The default is &#39;cpu&#39;.</span>
<span class="sd">    sens_params : dict, optional</span>
<span class="sd">        Dictionary that contains the parameters for the sensitivity analysis.</span>
<span class="sd">        Key &#39;method&#39; defines the method for sensitivity analysis: &#39;gradient&#39; or &#39;perturbation&#39;.</span>
<span class="sd">        Key &#39;comp&#39; defines whether gradients are computed for sensitivity analysis.</span>
<span class="sd">        Key &#39;plot&#39; defines whether the results of the sensitivity analysis are visualized.</span>
<span class="sd">        Key &#39;verbose&#39; defines whether the information about the sensitivity analysis is printed.</span>
<span class="sd">        Key &#39;sens_length&#39; defines the number of randomly sampled subset of timesteps for the analysis.</span>
<span class="sd">        (If not a multiple of the model&#39;s forecast, the number will be rounded up to the next multiple.)</span>
<span class="sd">        The default is None, i.e. no sensitivity analysis is computed.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    if comp_sens is False:</span>
<span class="sd">        torch.Tensor : Tensor of same langth as input, containing the predictions.</span>
<span class="sd">    if comp_sens is True:</span>
<span class="sd">        (torch.Tensor, dict) : Tuple of Tensor of same length as input and sensitivity dict.</span>
<span class="sd">        Key is the prediction type, value is the sensitivity tensor.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">fc</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">forecast</span>
    <span class="n">prediction_type</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">Pred_Type</span>
    <span class="k">if</span> <span class="n">prediction_type</span> <span class="o">==</span> <span class="s2">&quot;Quantile&quot;</span><span class="p">:</span>
        <span class="n">num_outputs</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">n_quantiles</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">num_outputs</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;Point&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
            <span class="s2">&quot;Mean_Var&quot;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="n">num_outputs</span> <span class="o">=</span> <span class="n">num_outputs</span><span class="p">[</span><span class="n">prediction_type</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">model</span><span class="o">.</span><span class="n">Ensemble</span><span class="p">:</span>
            <span class="n">num_outputs</span> <span class="o">=</span> <span class="mi">2</span>

    <span class="c1"># The Model starts with zeros as recurrent System state</span>
    <span class="n">size</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">window_size</span><span class="p">,</span> <span class="n">model</span><span class="o">.</span><span class="n">rnn_window</span><span class="p">)</span>
    <span class="n">prediction</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">num_outputs</span><span class="p">,</span> <span class="n">model</span><span class="o">.</span><span class="n">pred_size</span><span class="p">,</span> <span class="n">size</span><span class="p">))</span>
    <span class="n">original_out</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">model</span><span class="o">.</span><span class="n">pred_size</span><span class="p">,</span> <span class="n">size</span><span class="p">))</span>
    <span class="n">x_rec</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">model</span><span class="o">.</span><span class="n">pred_size</span><span class="p">,</span> <span class="n">model</span><span class="o">.</span><span class="n">rnn_window</span><span class="p">)</span>

    <span class="c1"># Tensors to device</span>
    <span class="n">x_rec</span> <span class="o">=</span> <span class="n">x_rec</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>
    <span class="n">prediction</span> <span class="o">=</span> <span class="n">prediction</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>
    <span class="n">original_out</span> <span class="o">=</span> <span class="n">original_out</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>
    <span class="n">model</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>

    <span class="n">checks</span> <span class="o">=</span> <span class="n">_check_sens_params_pred</span><span class="p">(</span><span class="n">sens_params</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">sens_params</span><span class="p">:</span>
        <span class="n">method</span><span class="p">,</span> <span class="n">comp_sens</span><span class="p">,</span> <span class="n">verbose</span><span class="p">,</span> <span class="n">sens_length</span><span class="p">,</span> <span class="n">num_samples</span><span class="p">,</span> <span class="n">std_dev</span><span class="p">,</span> <span class="n">correlated</span><span class="p">,</span> <span class="n">random_samples</span><span class="p">,</span> <span class="n">amplification</span> <span class="o">=</span> <span class="n">checks</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">comp_sens</span><span class="p">,</span> <span class="n">verbose</span> <span class="o">=</span> <span class="n">checks</span> <span class="c1"># False</span>

    <span class="c1"># Initialise 3D tensor for sensitivity analysis</span>
    <span class="k">if</span> <span class="n">comp_sens</span><span class="p">:</span>
        <span class="n">flatten_size</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">window_size</span><span class="o">*</span><span class="n">model</span><span class="o">.</span><span class="n">input_channels</span> <span class="o">+</span> <span class="n">model</span><span class="o">.</span><span class="n">rnn_window</span><span class="o">*</span><span class="n">model</span><span class="o">.</span><span class="n">pred_size</span>
        <span class="n">num_timesteps</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">dataloader</span><span class="p">)</span><span class="o">*</span><span class="n">fc</span>
        <span class="n">loader_length</span> <span class="o">=</span> <span class="n">num_timesteps</span> <span class="o">-</span> <span class="n">dataloader</span><span class="o">.</span><span class="n">dataset</span><span class="o">.</span><span class="n">subclass</span><span class="o">.</span><span class="n">add_zero</span>
        <span class="n">sens_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dataloader</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">sens_length</span><span class="p">:</span>
            <span class="n">num_timesteps</span><span class="p">,</span> <span class="n">sens_indices</span> <span class="o">=</span> <span class="n">_random_subset_sens_indices</span><span class="p">(</span><span class="n">sens_length</span><span class="p">,</span> <span class="n">fc</span><span class="p">,</span> <span class="n">model</span><span class="o">.</span><span class="n">Type</span><span class="p">,</span> <span class="n">dataloader</span><span class="p">)</span>
        
        <span class="n">sens_mean</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">num_timesteps</span><span class="p">,</span> <span class="n">model</span><span class="o">.</span><span class="n">pred_size</span><span class="p">,</span> <span class="n">flatten_size</span><span class="p">),</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;nan&#39;</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">prediction_type</span> <span class="o">==</span> <span class="s2">&quot;Mean_Var&quot;</span> <span class="ow">or</span> <span class="n">model</span><span class="o">.</span><span class="n">Ensemble</span><span class="p">:</span>
            <span class="n">sens_var</span> <span class="o">=</span> <span class="n">sens_mean</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">random_samples</span><span class="p">:</span>
                <span class="n">sens_uq</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">num_timesteps</span><span class="p">,</span> <span class="n">random_samples</span><span class="p">,</span> <span class="n">model</span><span class="o">.</span><span class="n">pred_size</span><span class="p">,</span> <span class="n">flatten_size</span><span class="p">),</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;nan&#39;</span><span class="p">))</span>
                <span class="n">eps</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">num_timesteps</span><span class="p">,</span> <span class="n">random_samples</span><span class="p">,</span> <span class="n">model</span><span class="o">.</span><span class="n">pred_size</span><span class="p">),</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;nan&#39;</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Start </span><span class="si">{</span><span class="n">method</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span><span class="si">}</span><span class="s1">-based Sensitivity Analysis...</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Shape of sensitivity tensor: </span><span class="si">{</span><span class="n">sens_mean</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

    <span class="c1"># Iterate over dataloader</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">data</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">tqdm</span><span class="p">(</span><span class="n">dataloader</span><span class="p">)</span> <span class="k">if</span> <span class="n">verbose</span> <span class="k">else</span> <span class="n">dataloader</span><span class="p">):</span>
        <span class="n">inputs</span><span class="p">,</span> <span class="n">output</span> <span class="o">=</span> <span class="n">data</span>
        <span class="n">inputs</span><span class="p">,</span> <span class="n">output</span> <span class="o">=</span> <span class="n">inputs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">),</span> <span class="n">output</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>

        <span class="c1"># Prepare input for model to allow autograd computing gradients of outputs w.r.t. inputs</span>
        <span class="n">inputs</span> <span class="o">=</span> <span class="n">Variable</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="n">start_dim</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="n">requires_grad</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">x_rec</span> <span class="o">=</span> <span class="n">Variable</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">x_rec</span><span class="p">,</span> <span class="n">start_dim</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="n">requires_grad</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">inp</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">((</span><span class="n">inputs</span><span class="p">,</span> <span class="n">x_rec</span><span class="p">),</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">comp_sens</span><span class="p">:</span>
            <span class="n">pred</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">forward_sens</span><span class="p">(</span><span class="n">inp</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">prediction_type</span> <span class="o">==</span> <span class="s1">&#39;Mean_Var&#39;</span> <span class="ow">or</span> <span class="n">model</span><span class="o">.</span><span class="n">Ensemble</span><span class="p">:</span>
            <span class="n">pred</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">estimate_uncertainty_mean_std</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="n">x_rec</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">pred</span> <span class="o">=</span> <span class="n">model</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="n">x_rec</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">comp_sens</span> <span class="ow">and</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">sens_indices</span><span class="p">:</span>
            <span class="n">sens_temp</span> <span class="o">=</span> <span class="n">_comp_sensitivity</span><span class="p">(</span><span class="n">method</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">inp</span><span class="p">,</span> <span class="n">pred</span><span class="p">,</span> <span class="n">num_samples</span><span class="p">,</span> <span class="n">std_dev</span><span class="p">,</span> <span class="n">correlated</span><span class="p">,</span> <span class="n">random_samples</span><span class="p">,</span> <span class="n">amplification</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">prediction_type</span> <span class="o">==</span> <span class="s2">&quot;Mean_Var&quot;</span> <span class="ow">or</span> <span class="n">model</span><span class="o">.</span><span class="n">Ensemble</span><span class="p">:</span>
                <span class="n">sens_mean</span><span class="p">[</span><span class="n">idx</span><span class="p">:</span><span class="n">idx</span><span class="o">+</span><span class="n">fc</span><span class="p">],</span> <span class="n">sens_var</span><span class="p">[</span><span class="n">idx</span><span class="p">:</span><span class="n">idx</span><span class="o">+</span><span class="n">fc</span><span class="p">]</span> <span class="o">=</span> <span class="n">sens_temp</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">sens_temp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">random_samples</span><span class="p">:</span>
                    <span class="n">sens_uq</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">eps</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">sens_temp</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">sens_temp</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">sens_mean</span><span class="p">[</span><span class="n">idx</span><span class="p">:</span><span class="n">idx</span><span class="o">+</span><span class="n">fc</span><span class="p">]</span> <span class="o">=</span> <span class="n">sens_temp</span>
            <span class="n">idx</span> <span class="o">+=</span> <span class="n">fc</span>
        
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">pred</span><span class="p">)</span> <span class="o">==</span> <span class="nb">tuple</span><span class="p">:</span>
            <span class="n">pred</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">pred</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">prediction_type</span> <span class="o">==</span> <span class="s2">&quot;Quantile&quot;</span><span class="p">:</span>
            <span class="c1"># QR uses a different output shape [1,pred_size,forecast,num_outputs] than other models [num_outputs,pred_size,forecast]</span>
            <span class="c1"># We can adjust for this by squeezing the first and swapping the remaining axes</span>
            <span class="n">pred</span> <span class="o">=</span> <span class="n">pred</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">pred</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">pred</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
            <span class="n">pred</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">pred</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        
        <span class="n">prediction</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">((</span><span class="n">prediction</span><span class="p">,</span>
                                <span class="n">pred</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">num_outputs</span><span class="p">,</span> <span class="n">model</span><span class="o">.</span><span class="n">pred_size</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)),</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">x_rec</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="n">prediction</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:,</span> <span class="o">-</span><span class="n">model</span><span class="o">.</span><span class="n">rnn_window</span><span class="p">:],</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="c1"># only feed back the mean values!</span>
        <span class="n">original_out</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">((</span><span class="n">original_out</span><span class="p">,</span>
                                    <span class="n">output</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">pred_size</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)),</span> <span class="mi">1</span><span class="p">)</span>
    
    <span class="c1"># cut zeros from initialisation</span>
    <span class="c1"># shape = [num_outputs, pred_size, len(dataset)] = [num_outputs, pred_size, forecast*len(dataloader)]</span>
    <span class="n">prediction</span> <span class="o">=</span> <span class="n">prediction</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">size</span><span class="p">:]</span>
    <span class="n">original_out</span> <span class="o">=</span> <span class="n">original_out</span><span class="p">[:,</span> <span class="n">size</span><span class="p">:]</span>

    <span class="n">cut_zeros</span> <span class="o">=</span> <span class="n">dataloader</span><span class="o">.</span><span class="n">dataset</span><span class="o">.</span><span class="n">subclass</span><span class="o">.</span><span class="n">add_zero</span>
    <span class="k">if</span> <span class="n">cut_zeros</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">prediction</span> <span class="o">=</span> <span class="n">prediction</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:</span><span class="o">-</span><span class="n">cut_zeros</span><span class="p">]</span>
        <span class="n">original_out</span> <span class="o">=</span> <span class="n">original_out</span><span class="p">[:,</span> <span class="p">:</span><span class="o">-</span><span class="n">cut_zeros</span><span class="p">]</span>

    <span class="n">prediction</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span>
    <span class="n">model</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="s1">&#39;cpu&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">comp_sens</span><span class="p">:</span>
        <span class="c1"># cut to the same length as the prediction</span>
        <span class="n">sens_mean</span> <span class="o">=</span> <span class="n">sens_mean</span><span class="p">[:</span><span class="n">loader_length</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">prediction_type</span> <span class="o">==</span> <span class="s2">&quot;Mean_Var&quot;</span> <span class="ow">or</span> <span class="n">model</span><span class="o">.</span><span class="n">Ensemble</span><span class="p">:</span>
            <span class="n">sens_var</span> <span class="o">=</span> <span class="n">sens_var</span><span class="p">[:</span><span class="n">loader_length</span><span class="p">]</span>
            <span class="n">sensitivity_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;Mean&#39;</span><span class="p">:</span> <span class="n">sens_mean</span><span class="o">.</span><span class="n">cpu</span><span class="p">(),</span> <span class="s1">&#39;Aleatoric_UQ&#39;</span><span class="p">:</span> <span class="n">sens_var</span><span class="o">.</span><span class="n">cpu</span><span class="p">()}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sensitivity_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;Point&#39;</span><span class="p">:</span> <span class="n">sens_mean</span><span class="o">.</span><span class="n">cpu</span><span class="p">()}</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">method</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span><span class="si">}</span><span class="s1">-based Sensitivity Analysis completed!</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">random_samples</span><span class="p">:</span> <span class="c1"># cut all lines that contain NaNs and flatten first two dimensions</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="n">mean</span><span class="p">,</span> <span class="n">std</span> <span class="o">=</span> <span class="n">prediction</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">),</span> <span class="n">torch</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">prediction</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">))</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Mean of predictions: </span><span class="si">{</span><span class="n">torch</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">mean</span><span class="p">,</span><span class="w"> </span><span class="n">decimals</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span><span class="si">}</span><span class="s1">, Std of predictions: </span><span class="si">{</span><span class="n">torch</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">std</span><span class="p">,</span><span class="w"> </span><span class="n">decimals</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">sens_uq</span><span class="p">,</span> <span class="n">eps</span> <span class="o">=</span> <span class="n">sens_uq</span><span class="o">.</span><span class="n">cpu</span><span class="p">(),</span> <span class="n">eps</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span>
            <span class="n">sens_uq</span> <span class="o">=</span> <span class="n">sens_uq</span><span class="p">[</span><span class="o">~</span><span class="n">torch</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">sens_uq</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">))]</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">start_dim</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">end_dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">eps</span> <span class="o">=</span> <span class="n">eps</span><span class="p">[</span><span class="o">~</span><span class="n">torch</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">eps</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">))]</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">start_dim</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">end_dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">prediction</span><span class="p">,</span> <span class="n">sensitivity_dict</span><span class="p">,</span> <span class="n">sens_uq</span><span class="p">,</span> <span class="n">eps</span>
        <span class="k">return</span> <span class="n">prediction</span><span class="p">,</span> <span class="n">sensitivity_dict</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">prediction</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_comp_perturb_sens</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">inputs</span><span class="p">,</span> <span class="n">pred</span><span class="p">,</span> <span class="n">perturb_size</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">std_dev</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span> <span class="n">correlated</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">random_samples</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">amplification</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the perturbation-based sensitivity of the output w.r.t. the inputs, also known as</span>
<span class="sd">    Permutation Feature Importance (PFI). The method is based on the paper by Altmann et al. (2010).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    model : Model consisting of nn.Modules</span>
<span class="sd">    inputs : torch.Tensor</span>
<span class="sd">        Input tensor with already concatenated external excitation and recurrent state signals,</span>
<span class="sd">        shape=[batch_size, input_channels*window_size + pred_size*rnn_window]</span>
<span class="sd">    pred : torch.Tensor</span>
<span class="sd">        Output tensor that contains the predictions,</span>
<span class="sd">        shape=[batch_size, pred_size, forecast]</span>
<span class="sd">    output : torch.Tensor</span>
<span class="sd">        Output tensor that contains the true values,</span>
<span class="sd">        shape=[batch_size, pred_size, forecast]</span>
<span class="sd">    perturb_size : int, optional</span>
<span class="sd">        Number of permutations per input feature. The default is 4.</span>
<span class="sd">    std_dev : float, optional</span>
<span class="sd">        Standard deviation of the Gaussian noise as form of permutation.</span>
<span class="sd">        The default is 0.2.</span>
<span class="sd">    correlated : bool, optional</span>
<span class="sd">        If True, the relative perturbations are decayed in a local area of the current feature</span>
<span class="sd">        to be perturbed, based on the strongest region of the signal&#39;s auto-correlation.</span>
<span class="sd">        The default is True, i.e. the perturbations are decayed.</span>
<span class="sd">    random_samples : int, optional</span>
<span class="sd">        Number of random samples to take for &quot;neural&quot; Monte Carlo uncertainty estimation for MVE models.</span>
<span class="sd">        The default is 0, i.e. no random samples are taken.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    sens_temp : torch.Tensor</span>
<span class="sd">        Sensitivity tensor as Jacobian that contains the gradients of the output w.r.t. the inputs,</span>
<span class="sd">        shape=[batch_size*forecast, pred_size, input_channels*window_size + pred_size*rnn_window]</span>
<span class="sd">    </span>
<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    AssertionError</span>
<span class="sd">        If the perturb_size is less than 1 or the std_dev is less than 0.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="n">perturb_size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;Permutation size must me greater than 0 for PFI!&#39;</span>
    <span class="k">assert</span> <span class="n">std_dev</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;Standard deviation for Gaussian noise must me greater than 0 for PFI!&#39;</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">random_samples</span><span class="p">:</span>
        <span class="n">torch</span><span class="o">.</span><span class="n">manual_seed</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
    <span class="n">steps</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">mean</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">std</span><span class="o">=</span><span class="n">std_dev</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="n">perturb_size</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">steps</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">!=</span> <span class="n">perturb_size</span><span class="o">//</span><span class="mi">2</span><span class="p">:</span> <span class="c1"># ensure that positive and negative perturbations are equal</span>
        <span class="n">steps</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">mean</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">std</span><span class="o">=</span><span class="n">std_dev</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="n">perturb_size</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

    <span class="n">batch_size</span><span class="p">,</span> <span class="n">pred_size</span><span class="p">,</span> <span class="n">forecast</span> <span class="o">=</span> <span class="n">pred</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span> <span class="k">if</span> <span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">Pred_Type</span> <span class="o">==</span> <span class="s1">&#39;Mean_Var&#39;</span> <span class="ow">or</span> <span class="n">model</span><span class="o">.</span><span class="n">Ensemble</span><span class="p">)</span> <span class="k">else</span> <span class="n">pred</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">flatten_size</span> <span class="o">=</span> <span class="n">inputs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">input_channels</span><span class="p">,</span> <span class="n">window_size</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">input_channels</span><span class="p">,</span> <span class="n">model</span><span class="o">.</span><span class="n">window_size</span>
    <span class="n">rec_start_idx</span> <span class="o">=</span> <span class="n">input_channels</span> <span class="o">*</span> <span class="n">window_size</span>
    <span class="n">rnn_window</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">rnn_window</span> <span class="k">if</span> <span class="n">model</span><span class="o">.</span><span class="n">Type</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;AR&#39;</span><span class="p">,</span> <span class="s1">&#39;AR_RNN&#39;</span><span class="p">]</span> <span class="k">else</span> <span class="mi">0</span>
    <span class="n">ch_size</span> <span class="o">=</span> <span class="p">(</span><span class="n">input_channels</span> <span class="o">+</span> <span class="n">pred_size</span><span class="p">)</span> <span class="k">if</span> <span class="n">model</span><span class="o">.</span><span class="n">Type</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;AR&#39;</span><span class="p">,</span> <span class="s1">&#39;AR_RNN&#39;</span><span class="p">]</span> <span class="k">else</span> <span class="n">input_channels</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">auto_correlation</span><span class="p">(</span><span class="n">signal</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute the auto-correlation of a channel signal&quot;&quot;&quot;</span>
        <span class="n">signal</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>
        <span class="n">signal</span> <span class="o">=</span> <span class="n">signal</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">signal</span><span class="p">)</span> <span class="c1"># zero-mean to avoid bias and make intervals more comparable</span>
        <span class="n">auto_cov</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">correlate</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">signal</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;full&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">auto_cov</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">auto_cov</span><span class="p">)</span> <span class="o">+</span> <span class="mf">1e-6</span><span class="p">)</span>
    
    <span class="k">def</span><span class="w"> </span><span class="nf">get_autocorrelations</span><span class="p">(</span><span class="n">inputs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get the auto-correlations of input and recurrent signals.&quot;&quot;&quot;</span>
        <span class="n">input_</span> <span class="o">=</span> <span class="n">inputs</span><span class="p">[:,:</span><span class="n">rec_start_idx</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">input_channels</span><span class="p">,</span> <span class="n">window_size</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">model</span><span class="o">.</span><span class="n">Type</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;AR&#39;</span><span class="p">,</span> <span class="s1">&#39;AR_RNN&#39;</span><span class="p">]:</span>
            <span class="n">x_rec</span> <span class="o">=</span> <span class="n">inputs</span><span class="p">[:,</span><span class="n">rec_start_idx</span><span class="p">:]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">pred_size</span><span class="p">,</span> <span class="n">rnn_window</span><span class="p">)</span>
        
        <span class="n">auto_corrs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">ch_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ch_size</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">ch_idx</span> <span class="o">&lt;</span> <span class="n">input_channels</span><span class="p">:</span>
                <span class="n">auto_cor</span> <span class="o">=</span> <span class="n">auto_correlation</span><span class="p">(</span><span class="n">input_</span><span class="p">[</span><span class="n">ch_idx</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">auto_cor</span> <span class="o">=</span> <span class="n">auto_correlation</span><span class="p">(</span><span class="n">x_rec</span><span class="p">[</span><span class="n">ch_idx</span><span class="o">-</span><span class="n">input_channels</span><span class="p">])</span>
            <span class="n">auto_corrs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">auto_cor</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">auto_corrs</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">get_decay</span><span class="p">(</span><span class="n">auto_corrs</span><span class="p">,</span> <span class="n">idx</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the decay values from the auto-correlations, including the indices from</span>
<span class="sd">        the slicing operation at the current position within the sliding window.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">model</span><span class="o">.</span><span class="n">Type</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;AR&#39;</span><span class="p">,</span> <span class="s1">&#39;AR_RNN&#39;</span><span class="p">]:</span>
            <span class="n">ch</span> <span class="o">=</span> <span class="n">idx</span><span class="o">//</span><span class="n">window_size</span> <span class="k">if</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="n">rec_start_idx</span> <span class="k">else</span> <span class="p">(</span><span class="n">idx</span><span class="o">-</span><span class="n">rec_start_idx</span><span class="p">)</span><span class="o">//</span><span class="n">rnn_window</span> <span class="o">+</span> <span class="n">input_channels</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="n">idx</span> <span class="o">%</span> <span class="n">window_size</span> <span class="k">if</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="n">rec_start_idx</span> <span class="k">else</span> <span class="p">(</span><span class="n">idx</span><span class="o">-</span><span class="n">rec_start_idx</span><span class="p">)</span> <span class="o">%</span> <span class="n">rnn_window</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ch</span><span class="p">,</span> <span class="n">pos</span> <span class="o">=</span> <span class="n">idx</span> <span class="o">//</span> <span class="n">window_size</span><span class="p">,</span> <span class="n">idx</span> <span class="o">%</span> <span class="n">window_size</span>
        <span class="n">win_size</span> <span class="o">=</span> <span class="n">window_size</span> <span class="k">if</span> <span class="n">ch</span> <span class="o">&lt;</span> <span class="n">input_channels</span> <span class="k">else</span> <span class="n">rnn_window</span>
        
        <span class="k">if</span> <span class="n">correlated</span><span class="p">:</span>
            <span class="n">auto_cor</span> <span class="o">=</span> <span class="n">auto_corrs</span><span class="p">[</span><span class="n">ch</span><span class="p">][</span><span class="n">win_size</span><span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="n">pos</span> <span class="p">:</span> <span class="mi">2</span><span class="o">*</span><span class="n">win_size</span><span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="n">pos</span><span class="p">]</span>
            <span class="n">zero_intersecs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">auto_cor</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">zero_intersecs</span> <span class="o">-</span> <span class="n">pos</span><span class="p">))</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">zero_intersecs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">win_size</span><span class="o">-</span><span class="n">idx</span>
            <span class="n">start</span><span class="p">,</span> <span class="n">stop</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">pos</span><span class="o">-</span><span class="n">p</span><span class="p">),</span> <span class="nb">min</span><span class="p">(</span><span class="n">pos</span><span class="o">+</span><span class="n">p</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">win_size</span><span class="p">)</span>
            <span class="n">decay</span> <span class="o">=</span> <span class="n">auto_cor</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">stop</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">decay</span><span class="p">,</span> <span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">)</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">pos</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">decay</span><span class="p">,</span> <span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">),</span> <span class="n">ch</span><span class="p">,</span> <span class="n">win_size</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">perturb_input</span><span class="p">(</span><span class="n">batched_input</span><span class="p">,</span> <span class="n">decay</span><span class="p">,</span> <span class="n">win_size</span><span class="p">,</span> <span class="n">ch</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Perturb the input signal with Gaussian noise, over the length of the</span>
<span class="sd">        auto-correlation period of the signal (until first intersection with x-axis).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">ch</span> <span class="o">&lt;</span> <span class="n">input_channels</span><span class="p">:</span> <span class="c1"># within input channels</span>
            <span class="n">input_</span> <span class="o">=</span> <span class="n">batched_input</span><span class="p">[:,:</span><span class="n">rec_start_idx</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">input_channels</span><span class="p">,</span> <span class="n">win_size</span><span class="p">)</span>
            <span class="n">input_</span><span class="p">[:,</span> <span class="n">ch</span><span class="p">,</span> <span class="n">start</span><span class="p">:</span><span class="n">stop</span><span class="p">]</span> <span class="o">*=</span> <span class="n">decay</span>
            <span class="k">return</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">((</span><span class="n">input_</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">start_dim</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="n">batched_input</span><span class="p">[:,</span><span class="n">rec_start_idx</span><span class="p">:]),</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span> <span class="c1"># within recurrent channels</span>
            <span class="n">x_rec</span> <span class="o">=</span> <span class="n">batched_input</span><span class="p">[:,</span><span class="n">rec_start_idx</span><span class="p">:]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">pred_size</span><span class="p">,</span> <span class="n">win_size</span><span class="p">)</span>
            <span class="n">x_rec</span><span class="p">[:,</span> <span class="n">ch</span><span class="o">-</span><span class="n">input_channels</span><span class="p">,</span> <span class="n">start</span><span class="p">:</span><span class="n">stop</span><span class="p">]</span> <span class="o">*=</span> <span class="n">decay</span>
            <span class="k">return</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">((</span><span class="n">batched_input</span><span class="p">[:,:</span><span class="n">rec_start_idx</span><span class="p">],</span> <span class="n">x_rec</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">start_dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)),</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">perturbation</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">inputs</span><span class="p">,</span> <span class="n">pred</span><span class="p">,</span> <span class="n">steps</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the RMS score of differences, coming from all perturbations</span>
<span class="sd">        of the inputs w.r.t. the reference output for one timestep.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sens_temp</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">batch_size</span><span class="o">*</span><span class="n">forecast</span><span class="p">,</span> <span class="n">pred_size</span><span class="p">,</span> <span class="n">flatten_size</span><span class="p">),</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;nan&#39;</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">batch_size</span><span class="p">):</span>
            <span class="n">batched_inp</span> <span class="o">=</span> <span class="n">inputs</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">perturb_size</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="c1"># shape = [perturb_size, flatten_size]</span>
            <span class="n">auto_corrs</span> <span class="o">=</span> <span class="n">get_autocorrelations</span><span class="p">(</span><span class="n">inputs</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span> <span class="k">if</span> <span class="n">correlated</span> <span class="k">else</span> <span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">ch_size</span><span class="p">)</span>
            
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">flatten_size</span><span class="p">):</span>
                <span class="n">decay</span><span class="p">,</span> <span class="n">start_stop</span><span class="p">,</span> <span class="n">ch</span><span class="p">,</span> <span class="n">win_size</span> <span class="o">=</span> <span class="n">get_decay</span><span class="p">(</span><span class="n">auto_corrs</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>
                <span class="n">decay</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">steps</span> <span class="o">*</span> <span class="n">decay</span>
                <span class="n">perturbed_inp</span> <span class="o">=</span> <span class="n">batched_inp</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span>
                <span class="n">perturbed_inp</span> <span class="o">=</span> <span class="n">perturb_input</span><span class="p">(</span><span class="n">perturbed_inp</span><span class="p">,</span> <span class="n">decay</span><span class="p">,</span> <span class="n">win_size</span><span class="p">,</span> <span class="n">ch</span><span class="p">,</span> <span class="o">*</span><span class="n">start_stop</span><span class="p">)</span>
                <span class="n">perturbed_pred</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">forward_sens</span><span class="p">(</span><span class="n">perturbed_inp</span><span class="p">)</span>  <span class="c1"># shape = [perturb_size, pred_size, forecast]</span>
                <span class="k">del</span> <span class="n">perturbed_inp</span>

                <span class="c1"># compute a sensitivity metric of all perturbations in each feature variation</span>
                <span class="k">if</span> <span class="n">model</span><span class="o">.</span><span class="n">Pred_Type</span> <span class="o">==</span> <span class="s1">&#39;Mean_Var&#39;</span> <span class="ow">or</span> <span class="n">model</span><span class="o">.</span><span class="n">Ensemble</span><span class="p">:</span>
                    <span class="n">differences</span> <span class="o">=</span> <span class="p">(</span><span class="n">perturbed_pred</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">pred</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="o">...</span><span class="p">])</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">differences</span> <span class="o">=</span> <span class="p">(</span><span class="n">perturbed_pred</span> <span class="o">-</span> <span class="n">pred</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="o">...</span><span class="p">])</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span>
                <span class="n">differences</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">differences</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">sens_temp</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="n">forecast</span><span class="p">:(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">forecast</span><span class="p">,:,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">differences</span><span class="o">.</span><span class="n">T</span> <span class="c1"># shape = [forecast, pred_size]</span>
        <span class="k">return</span> <span class="n">sens_temp</span>
        
    <span class="c1"># Compute and return the differences from the perturbations</span>
    <span class="k">if</span> <span class="n">model</span><span class="o">.</span><span class="n">Pred_Type</span> <span class="o">==</span> <span class="s1">&#39;Point&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">perturbation</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">inputs</span><span class="p">,</span> <span class="n">pred</span><span class="p">,</span> <span class="n">steps</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">model</span><span class="o">.</span><span class="n">Pred_Type</span> <span class="o">==</span> <span class="s1">&#39;Mean_Var&#39;</span> <span class="ow">or</span> <span class="n">model</span><span class="o">.</span><span class="n">Ensemble</span><span class="p">:</span>
        <span class="n">mean_pred</span><span class="p">,</span> <span class="n">var_pred</span> <span class="o">=</span> <span class="n">pred</span>
        <span class="n">sens_temp_mean</span> <span class="o">=</span> <span class="n">perturbation</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">inputs</span><span class="p">,</span> <span class="n">mean_pred</span><span class="p">,</span> <span class="n">steps</span><span class="p">)</span>
        <span class="n">sens_temp_var</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">sens_temp_mean</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">random_samples</span><span class="p">:</span>
            <span class="n">permutations</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">random_samples</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">*</span><span class="n">forecast</span><span class="p">,</span> <span class="n">pred_size</span><span class="p">,</span> <span class="n">flatten_size</span><span class="p">),</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;nan&#39;</span><span class="p">))</span>
            <span class="n">samples</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">random_samples</span><span class="p">,</span> <span class="n">pred_size</span><span class="p">),</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;nan&#39;</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">random_samples</span><span class="p">):</span> <span class="c1"># not direct sampling, but reparametrization trick: mean + eps*std, with eps ~ N(0,1)</span>
                <span class="n">eps</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">pred_size</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">amplification</span> <span class="c1"># used for later up-scaling</span>
                <span class="n">sampled_pred</span> <span class="o">=</span> <span class="n">mean_pred</span> <span class="o">+</span> <span class="n">eps</span> <span class="o">*</span> <span class="n">torch</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">var_pred</span><span class="p">)</span>
                <span class="n">permutations</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">perturbation</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">inputs</span><span class="p">,</span> <span class="n">sampled_pred</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">steps</span><span class="p">)</span>
                <span class="n">samples</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">eps</span><span class="p">[</span><span class="mi">0</span><span class="p">,:,</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span>
            <span class="n">sens_temp_var</span> <span class="o">=</span> <span class="n">permutations</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">sens_temp_mean</span><span class="p">,</span> <span class="n">sens_temp_var</span><span class="p">,</span> <span class="n">permutations</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="n">samples</span>
        <span class="k">return</span> <span class="n">sens_temp_mean</span><span class="p">,</span> <span class="n">sens_temp_var</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_comp_sensitivity</span><span class="p">(</span><span class="n">method</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">inp</span><span class="p">,</span> <span class="n">pred</span><span class="p">,</span> <span class="n">num_samples</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">std_dev</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span> <span class="n">correlated</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">random_samples</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">amplification</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Abatracted mathod that computes the sensitivity analysis for each step in the dataloader</span>
<span class="sd">    based on the given method.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    method : The method to use for sensitivity analysis.</span>
<span class="sd">    model : Model consisting of nn.Modules</span>
<span class="sd">    inputs : torch.Tensor</span>
<span class="sd">        Input tensor with already concatenated external excitation and recurrent state signals,</span>
<span class="sd">        shape=[batch_size, input_channels*window_size + pred_size*rnn_window]</span>
<span class="sd">    pred : torch.Tensor</span>
<span class="sd">        Output tensor that contains the predictions,</span>
<span class="sd">        shape=[batch_size, pred_size, forecast]</span>
<span class="sd">    num_samples : int, optional</span>
<span class="sd">        Number of permutations per input feature. The default is 4.</span>
<span class="sd">    std_dev : float, optional</span>
<span class="sd">        Standard deviation of the Gaussian noise as form of permutation.</span>
<span class="sd">        The default is 0.2.</span>
<span class="sd">    correlated : bool, optional</span>
<span class="sd">        If True, the perturbations are based on the auto-correlation of the signals.</span>
<span class="sd">        The default is True.</span>
<span class="sd">    random_samples : int, optional</span>
<span class="sd">        Number of random samples, drawn from a standard normal distribution, to approximate the</span>
<span class="sd">        expected sensitivity range across the aleatoric uncertainty of MVE models.</span>
<span class="sd">        The default is 0 samples, i.e. no sampling is performed.</span>
<span class="sd">    amplification : float, optional</span>
<span class="sd">        Factor to amplify the sensitivity gradients when performing the sensitivity analysis</span>
<span class="sd">        under re-sampling for MVE models. The default is 1, i.e. no amplification.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    The computed sensitivity analysis result. In case of an MVE model, the result is a tuple,</span>
<span class="sd">    containing the mean and variance of the sensitivity analysis.</span>
<span class="sd">    </span>
<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError: If an invalid method is given for the sensitivity analysis.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">method</span> <span class="o">=</span> <span class="n">method</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="n">SensitivityMethods</span><span class="o">.</span><span class="n">GRADIENT</span><span class="o">.</span><span class="n">value</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_comp_grad_sens</span><span class="p">(</span><span class="n">inp</span><span class="p">,</span> <span class="n">pred</span><span class="p">,</span> <span class="n">model</span><span class="o">.</span><span class="n">Pred_Type</span><span class="p">,</span> <span class="n">model</span><span class="o">.</span><span class="n">Ensemble</span><span class="p">,</span> <span class="n">random_samples</span><span class="p">,</span> <span class="n">amplification</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="n">SensitivityMethods</span><span class="o">.</span><span class="n">SMOOTH_GRAD</span><span class="o">.</span><span class="n">value</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_comp_smooth_grad_sens</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">inp</span><span class="p">,</span> <span class="n">pred</span><span class="p">,</span> <span class="n">model</span><span class="o">.</span><span class="n">Pred_Type</span><span class="p">,</span> <span class="n">model</span><span class="o">.</span><span class="n">Ensemble</span><span class="p">,</span> <span class="n">num_samples</span><span class="p">,</span> <span class="n">std_dev</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="n">SensitivityMethods</span><span class="o">.</span><span class="n">INTEGRATED_GRADIENT</span><span class="o">.</span><span class="n">value</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_comp_integrated_grad_sens</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">inp</span><span class="p">,</span> <span class="n">pred</span><span class="p">,</span> <span class="n">model</span><span class="o">.</span><span class="n">Pred_Type</span><span class="p">,</span> <span class="n">model</span><span class="o">.</span><span class="n">Ensemble</span><span class="p">,</span> <span class="n">num_samples</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="n">SensitivityMethods</span><span class="o">.</span><span class="n">PERTURBATION</span><span class="o">.</span><span class="n">value</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_comp_perturb_sens</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">inp</span><span class="p">,</span> <span class="n">pred</span><span class="p">,</span> <span class="n">num_samples</span><span class="p">,</span> <span class="n">std_dev</span><span class="p">,</span> <span class="n">correlated</span><span class="p">,</span> <span class="n">random_samples</span><span class="p">,</span> <span class="n">amplification</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">((</span><span class="sa">f</span><span class="s2">&quot;Given method &#39;</span><span class="si">{</span><span class="n">method</span><span class="si">}</span><span class="s2">&#39; is not implemented! Choose from: &quot;</span>
                          <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="nb">list</span><span class="p">(</span><span class="n">SensitivityMethods</span><span class="o">.</span><span class="n">__members__</span><span class="p">)]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">))</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_check_sens_params_pred</span><span class="p">(</span><span class="n">sens_params</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Check the sensitivity parameters for all AR and RNN models.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    sens_params : dict</span>
<span class="sd">        Dictionary that contains the parameters for the sensitivity analysis.</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    if sens_params is given / not None:</span>
<span class="sd">        tuple : method, comp_sens, verbose, sens_length, num_samples, std_dev,</span>
<span class="sd">        correlated, random_samples, amplification</span>
<span class="sd">    elif sens_params is None:</span>
<span class="sd">        bool : comp_sens</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">sens_params</span><span class="p">:</span>
        <span class="n">method</span> <span class="o">=</span> <span class="n">sens_params</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;method&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>
        <span class="n">comp_sens</span> <span class="o">=</span> <span class="n">sens_params</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;comp&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="n">verbose</span> <span class="o">=</span> <span class="n">sens_params</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;verbose&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="n">sens_length</span> <span class="o">=</span> <span class="n">sens_params</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;sens_length&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">num_samples</span> <span class="o">=</span> <span class="n">sens_params</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;num_samples&#39;</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
        <span class="n">std_dev</span> <span class="o">=</span> <span class="n">sens_params</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;std_dev&#39;</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">)</span>
        <span class="n">correlated</span> <span class="o">=</span> <span class="n">sens_params</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;correlated&#39;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="n">random_samples</span> <span class="o">=</span> <span class="n">sens_params</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;random_samples&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">amplification</span> <span class="o">=</span> <span class="n">sens_params</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;amplification&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">method</span><span class="p">,</span> <span class="n">comp_sens</span><span class="p">,</span> <span class="n">verbose</span><span class="p">,</span> <span class="n">sens_length</span><span class="p">,</span> <span class="n">num_samples</span><span class="p">,</span> <span class="n">std_dev</span><span class="p">,</span> <span class="n">correlated</span><span class="p">,</span> <span class="n">random_samples</span><span class="p">,</span> <span class="n">amplification</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">comp_sens</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="n">comp_sens</span><span class="p">,</span> <span class="n">verbose</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_random_subset_sens_indices</span><span class="p">(</span><span class="n">sens_length</span><span class="p">,</span> <span class="n">forecast</span><span class="p">,</span> <span class="n">m_type</span><span class="p">,</span> <span class="n">dataloader</span><span class="p">,</span> <span class="n">batched</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create random indices for sensitivity analysis that</span>
<span class="sd">    are a subset of the dataloader indices, allowing for faster prediction.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    sens_length : int</span>
<span class="sd">        Desired size for the reduced points that the sensitivity analysis is computed on</span>
<span class="sd">    forecast : int</span>
<span class="sd">        The model&#39;s forecast length</span>
<span class="sd">    m_type : str</span>
<span class="sd">        The model type, specified as object attribute in &quot;model.Type&quot;</span>
<span class="sd">    dataloader : Dataloader</span>
<span class="sd">        Dataloader for the test dataset to predict the output for.</span>
<span class="sd">    batched : bool, optional</span>
<span class="sd">        If True, the dataloader is batched, i.e. only used for &quot;_pred_ARNN_batch&quot; function.</span>
<span class="sd">        The default is False.</span>


<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    num_timesteps : int</span>
<span class="sd">        Number of timesteps for sensitivity analysis</span>
<span class="sd">    sens_indices : list</span>
<span class="sd">        List of indices that are used for the sensitivity analysis</span>
<span class="sd">    </span>
<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    AssertionError</span>
<span class="sd">        If the given sensitivity length is smaller than forecast length times batch size.</span>
<span class="sd">    AssertionError</span>
<span class="sd">        If the given sensitivity length exceeds the maximum length of the dataloader.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">sens_length</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">sens_length</span><span class="p">)</span>
    <span class="n">batch_size</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="n">dataloader</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="n">m_type</span> <span class="o">==</span> <span class="s1">&#39;RNN&#39;</span> <span class="k">else</span> <span class="mi">1</span>
    <span class="n">fc</span><span class="p">,</span> <span class="n">bs</span> <span class="o">=</span> <span class="n">forecast</span><span class="p">,</span> <span class="n">batch_size</span>

    <span class="k">assert</span> <span class="n">sens_length</span> <span class="o">&gt;=</span> <span class="n">fc</span><span class="o">*</span><span class="n">bs</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;Given sensitivity length of </span><span class="si">{</span><span class="n">sens_length</span><span class="si">}</span><span class="s1"> must be at least of size </span><span class="si">{</span><span class="n">fc</span><span class="o">*</span><span class="n">bs</span><span class="si">}</span><span class="s1">!&#39;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">batched</span><span class="p">:</span>
        <span class="n">num_timesteps</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">dataloader</span><span class="o">.</span><span class="n">dataset</span><span class="p">)</span><span class="o">*</span><span class="n">fc</span>
        <span class="n">loader_length</span> <span class="o">=</span> <span class="n">num_timesteps</span> <span class="o">-</span> <span class="n">dataloader</span><span class="o">.</span><span class="n">dataset</span><span class="o">.</span><span class="n">subclass</span><span class="o">.</span><span class="n">add_zero</span>
        <span class="k">assert</span> <span class="n">sens_length</span> <span class="o">&lt;=</span> <span class="n">loader_length</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;Given sensitivity length of </span><span class="si">{</span><span class="n">sens_length</span><span class="si">}</span><span class="s1"> exceeds maximum dataloader length of </span><span class="si">{</span><span class="n">loader_length</span><span class="si">}</span><span class="s1">!&#39;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">num_timesteps</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">dataloader</span><span class="p">)</span><span class="o">*</span><span class="n">forecast</span>
        <span class="k">assert</span> <span class="n">sens_length</span> <span class="o">&lt;=</span> <span class="n">num_timesteps</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;Given sensitivity length of </span><span class="si">{</span><span class="n">sens_length</span><span class="si">}</span><span class="s1"> exceeds maximum dataloader length of </span><span class="si">{</span><span class="n">num_timesteps</span><span class="si">}</span><span class="s1">!&#39;</span>
        <span class="n">add_zeros</span> <span class="o">=</span> <span class="p">[</span><span class="n">sw</span><span class="o">.</span><span class="n">add_zero</span> <span class="k">for</span> <span class="n">sw</span> <span class="ow">in</span> <span class="n">dataloader</span><span class="o">.</span><span class="n">sws</span><span class="p">]</span>
        <span class="n">min_length</span> <span class="o">=</span> <span class="nb">min</span><span class="p">([</span><span class="n">le</span><span class="o">*</span><span class="n">forecast</span><span class="o">-</span><span class="n">zeros</span> <span class="k">for</span> <span class="n">le</span><span class="p">,</span> <span class="n">zeros</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">dataloader</span><span class="o">.</span><span class="n">__lengths__</span><span class="p">(),</span> <span class="n">add_zeros</span><span class="p">)])</span>

    <span class="c1"># round sens_length to the closest multiple of forecast*batch_size if needed</span>
    <span class="k">if</span> <span class="n">sens_length</span> <span class="o">%</span> <span class="p">(</span><span class="n">fc</span><span class="o">*</span><span class="n">bs</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">sens_length</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">around</span><span class="p">(</span><span class="n">sens_length</span><span class="o">/</span><span class="p">(</span><span class="n">fc</span><span class="o">*</span><span class="n">bs</span><span class="p">))</span> <span class="k">if</span> <span class="n">m_type</span> <span class="o">==</span> <span class="s1">&#39;RNN&#39;</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">sens_length</span><span class="o">/</span><span class="p">(</span><span class="n">fc</span><span class="o">*</span><span class="n">bs</span><span class="p">))</span>
        <span class="n">sens_length</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">sens_length</span> <span class="o">*</span> <span class="n">fc</span><span class="o">*</span><span class="n">bs</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;INFO: Given sensitivity length was rounded to </span><span class="si">{</span><span class="n">sens_length</span><span class="si">}</span><span class="s1"> as closest multiple of batch_size=</span><span class="si">{</span><span class="n">bs</span><span class="si">}</span><span class="s1"> * forecast=</span><span class="si">{</span><span class="n">fc</span><span class="si">}</span><span class="s1">.&#39;</span><span class="p">)</span>
    <span class="n">num_timesteps</span> <span class="o">=</span> <span class="n">sens_length</span>
    <span class="n">sampler</span> <span class="o">=</span> <span class="n">LatinHypercube</span><span class="p">(</span><span class="n">d</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">samples</span> <span class="o">=</span> <span class="n">sampler</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="n">sens_length</span><span class="o">//</span><span class="p">(</span><span class="n">fc</span><span class="o">*</span><span class="n">bs</span><span class="p">))</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>

    <span class="c1"># fill up sens_indices in case of duplications until desired sens_length is reached</span>
    <span class="n">min_length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">dataloader</span><span class="p">)</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">batched</span> <span class="k">else</span> <span class="n">min_length</span>
    <span class="n">sens_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">samples</span> <span class="o">*</span> <span class="n">min_length</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">unique_indices</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">sens_indices</span><span class="p">)</span>
    <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">unique_indices</span><span class="p">)</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">sens_length</span><span class="o">//</span><span class="p">(</span><span class="n">fc</span><span class="o">*</span><span class="n">bs</span><span class="p">)):</span>
        <span class="n">additional_samples</span> <span class="o">=</span> <span class="n">sampler</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="p">(</span><span class="n">sens_length</span><span class="o">//</span><span class="p">(</span><span class="n">fc</span><span class="o">*</span><span class="n">bs</span><span class="p">))</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">unique_indices</span><span class="p">))</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="n">additional_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">additional_samples</span> <span class="o">*</span> <span class="n">min_length</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">unique_indices</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">additional_indices</span><span class="p">)</span>
    <span class="n">sens_indices</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">unique_indices</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">num_timesteps</span><span class="p">,</span> <span class="n">sens_indices</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_compress_model</span><span class="p">(</span><span class="n">old_model</span><span class="p">,</span> <span class="n">state_dict_path</span><span class="p">,</span> <span class="n">new_window_size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">new_rnn_window</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">retrain</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">retrain_params</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compress the first layer of an ARNN model by reducing the input and recurrent window sizes.</span>
<span class="sd">    Additional option to fine-tune the compressed model after compression.</span>
<span class="sd">    INFO: Currently NOT working for ensemble and RNN models!</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    old_model : nn.Module</span>
<span class="sd">        The old NN model to compress</span>
<span class="sd">    state_dict_path : str</span>
<span class="sd">        Path to the saved state dict of the old model</span>
<span class="sd">    new_window_size : int</span>
<span class="sd">        New window size for the input features</span>
<span class="sd">    new_rnn_window : int</span>
<span class="sd">        New window size for the recurrent features</span>
<span class="sd">    retrain : bool, optional</span>
<span class="sd">        If True, fine-tune the new model after compression. The default is False.</span>
<span class="sd">    data_handle : data_handle object, optional</span>
<span class="sd">        Object from Meas_handling module to load and prepare the data for retraining.</span>
<span class="sd">        Only needed if retrain=True. The default is None, i.e. not provided.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    new_model : nn.Module</span>
<span class="sd">        The compressed model with reduced input and recurrent window sizes.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Get the name of all first weight tensors</span>
    <span class="n">weight_names</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">old_model</span><span class="o">.</span><span class="n">named_parameters</span><span class="p">():</span>
        <span class="k">if</span> <span class="s1">&#39;0.weight&#39;</span> <span class="ow">in</span> <span class="n">name</span><span class="p">:</span>
            <span class="n">weight_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

    <span class="c1"># Load the saved weights</span>
    <span class="n">state_dict</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">state_dict_path</span><span class="p">)</span>

    <span class="c1"># Extract and reduce the first weight matrix</span>
    <span class="k">for</span> <span class="n">w_name</span> <span class="ow">in</span> <span class="n">weight_names</span><span class="p">:</span>
        <span class="n">w_mat</span> <span class="o">=</span> <span class="n">state_dict</span><span class="p">[</span><span class="n">w_name</span><span class="p">]</span>
        <span class="n">rec_start_idx</span> <span class="o">=</span> <span class="n">old_model</span><span class="o">.</span><span class="n">input_channels</span> <span class="o">*</span> <span class="n">old_model</span><span class="o">.</span><span class="n">window_size</span>
        <span class="k">if</span> <span class="n">new_window_size</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">new_window_size</span> <span class="o">&lt;=</span> <span class="n">old_model</span><span class="o">.</span><span class="n">window_size</span><span class="p">,</span> <span class="s1">&#39;New window_size must be smaller or equal than the old one!&#39;</span>
            <span class="n">temp_inp</span> <span class="o">=</span> <span class="n">w_mat</span><span class="p">[:,</span> <span class="p">:</span><span class="n">rec_start_idx</span><span class="p">]</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">w_mat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">old_model</span><span class="o">.</span><span class="n">window_size</span><span class="p">)</span>
            <span class="n">temp_inp</span> <span class="o">=</span> <span class="n">temp_inp</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="o">-</span><span class="n">new_window_size</span><span class="p">:]</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">start_dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># take only the _last_ new_window_size columns</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_window_size</span> <span class="o">=</span> <span class="n">old_model</span><span class="o">.</span><span class="n">window_size</span>
            <span class="n">temp_inp</span> <span class="o">=</span> <span class="n">w_mat</span><span class="p">[:,</span> <span class="p">:</span><span class="n">rec_start_idx</span><span class="p">]</span>
        
        <span class="k">if</span> <span class="n">new_rnn_window</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">new_rnn_window</span> <span class="o">&lt;=</span> <span class="n">old_model</span><span class="o">.</span><span class="n">rnn_window</span><span class="p">,</span> <span class="s1">&#39;New rnn_window_size must be smaller or equal than the old one!&#39;</span>
            <span class="n">temp_rec</span> <span class="o">=</span> <span class="n">w_mat</span><span class="p">[:,</span> <span class="n">rec_start_idx</span><span class="p">:]</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">w_mat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">old_model</span><span class="o">.</span><span class="n">rnn_window</span><span class="p">)</span>
            <span class="n">temp_rec</span> <span class="o">=</span> <span class="n">temp_rec</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="o">-</span><span class="n">new_rnn_window</span><span class="p">:]</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">start_dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_rnn_window</span> <span class="o">=</span> <span class="n">old_model</span><span class="o">.</span><span class="n">rnn_window</span>
            <span class="n">temp_rec</span> <span class="o">=</span> <span class="n">w_mat</span><span class="p">[:,</span> <span class="n">rec_start_idx</span><span class="p">:]</span>
        <span class="n">state_dict</span><span class="p">[</span><span class="n">w_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">((</span><span class="n">temp_inp</span><span class="p">,</span> <span class="n">temp_rec</span><span class="p">),</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="n">new_params</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;window_size&#39;</span><span class="p">:</span> <span class="n">new_window_size</span><span class="p">,</span> <span class="s1">&#39;rnn_window&#39;</span><span class="p">:</span> <span class="n">new_rnn_window</span><span class="p">}</span>
    <span class="c1"># Extract __init__ parameters and create a new model with modified window sizes</span>
    <span class="bp">cls</span> <span class="o">=</span> <span class="n">old_model</span><span class="o">.</span><span class="vm">__class__</span>
    <span class="n">parameters</span> <span class="o">=</span> <span class="n">inspect</span><span class="o">.</span><span class="n">signature</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="fm">__init__</span><span class="p">)</span><span class="o">.</span><span class="n">parameters</span>
    <span class="n">init_params</span> <span class="o">=</span> <span class="p">{</span><span class="n">param</span><span class="p">:</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">old_model</span><span class="p">,</span> <span class="n">param</span><span class="p">)</span> <span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="n">parameters</span> <span class="k">if</span> <span class="n">param</span> <span class="o">!=</span> <span class="s1">&#39;self&#39;</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">old_model</span><span class="p">,</span> <span class="n">param</span><span class="p">)}</span>
    <span class="n">model_temp</span> <span class="o">=</span> <span class="n">old_model</span><span class="o">.</span><span class="n">DNN</span> <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">old_model</span><span class="p">,</span> <span class="s1">&#39;DNN&#39;</span><span class="p">)</span> <span class="k">else</span> <span class="n">old_model</span>
    <span class="n">parameters</span> <span class="o">=</span> <span class="n">inspect</span><span class="o">.</span><span class="n">signature</span><span class="p">(</span><span class="n">model_temp</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="fm">__init__</span><span class="p">)</span><span class="o">.</span><span class="n">parameters</span>
    <span class="n">wrong_keys</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;input_size&#39;</span><span class="p">,</span> <span class="s1">&#39;output_size&#39;</span><span class="p">]</span>
    <span class="n">init_params_dnn</span> <span class="o">=</span> <span class="p">{</span><span class="n">param</span><span class="p">:</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">model_temp</span><span class="p">,</span> <span class="n">param</span><span class="p">)</span> <span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="n">parameters</span> <span class="k">if</span> <span class="n">param</span> <span class="o">!=</span> <span class="s1">&#39;self&#39;</span>
                   <span class="ow">and</span> <span class="n">param</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">wrong_keys</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">model_temp</span><span class="p">,</span> <span class="n">param</span><span class="p">)}</span>
    <span class="n">init_params</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">init_params_dnn</span><span class="p">)</span>
    <span class="k">if</span> <span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;SeparateMVEARNN&#39;</span><span class="p">:</span>
        <span class="n">init_params</span><span class="p">[</span><span class="s1">&#39;var_hidden_size&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">init_params</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;hidden_size&#39;</span><span class="p">)</span>
    
    <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">init_params</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">wrapped_model</span> <span class="o">=</span> <span class="n">value</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">)</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">wrapped_model</span><span class="p">:</span>
            <span class="n">wrapped_params</span> <span class="o">=</span> <span class="n">inspect</span><span class="o">.</span><span class="n">signature</span><span class="p">(</span><span class="n">wrapped_model</span><span class="o">.</span><span class="fm">__init__</span><span class="p">)</span><span class="o">.</span><span class="n">parameters</span>
            <span class="n">wrapped_init_params</span> <span class="o">=</span> <span class="p">{</span><span class="n">param</span><span class="p">:</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">wrapped_model</span><span class="p">,</span> <span class="n">param</span><span class="p">)</span> <span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="n">wrapped_params</span> \
                                   <span class="k">if</span> <span class="n">param</span> <span class="o">!=</span> <span class="s1">&#39;self&#39;</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">wrapped_model</span><span class="p">,</span> <span class="n">param</span><span class="p">)}</span>

            <span class="n">wrapped_init_params</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">new_params</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">wrapped_init_params</span><span class="p">})</span>
            <span class="n">model_temp</span> <span class="o">=</span> <span class="n">wrapped_model</span><span class="o">.</span><span class="n">DNN</span> <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">wrapped_model</span><span class="p">,</span> <span class="s1">&#39;DNN&#39;</span><span class="p">)</span> <span class="k">else</span> <span class="n">wrapped_model</span>
            <span class="n">parameters</span> <span class="o">=</span> <span class="n">inspect</span><span class="o">.</span><span class="n">signature</span><span class="p">(</span><span class="n">model_temp</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="fm">__init__</span><span class="p">)</span><span class="o">.</span><span class="n">parameters</span>
            <span class="n">init_params_dnn</span> <span class="o">=</span> <span class="p">{</span><span class="n">param</span><span class="p">:</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">model_temp</span><span class="p">,</span> <span class="n">param</span><span class="p">)</span> <span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="n">parameters</span> <span class="k">if</span> <span class="n">param</span> <span class="o">!=</span> <span class="s1">&#39;self&#39;</span>
                        <span class="ow">and</span> <span class="n">param</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">wrong_keys</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">model_temp</span><span class="p">,</span> <span class="n">param</span><span class="p">)}</span>
            <span class="n">wrapped_init_params</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">init_params_dnn</span><span class="p">)</span>

            <span class="n">new_wrapped_model</span> <span class="o">=</span> <span class="n">wrapped_model</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="o">**</span><span class="n">wrapped_init_params</span><span class="p">)</span>
            <span class="n">init_params</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_wrapped_model</span>
            <span class="c1"># print(&#39;wrapped_init_params:&#39;, wrapped_init_params, &#39;\n&#39;)</span>
            <span class="k">break</span>
    
    <span class="k">if</span> <span class="s1">&#39;window_size&#39;</span> <span class="ow">in</span> <span class="n">init_params</span><span class="p">:</span> <span class="c1"># indicates that the outer model is of type nn.Module</span>
        <span class="n">init_params</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">new_params</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">init_params</span><span class="p">})</span>
    <span class="c1"># print(&#39;init_params:&#39;, init_params, &#39;\n&#39;)</span>

    <span class="c1"># Instantiate a new model with updated parameters and load the modified state dict</span>
    <span class="n">compressed_model</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="o">**</span><span class="n">init_params</span><span class="p">)</span>
    <span class="n">compressed_model</span><span class="o">.</span><span class="n">load_state_dict</span><span class="p">(</span><span class="n">state_dict</span><span class="p">)</span>

    <span class="n">params_old</span> <span class="o">=</span> <span class="n">summary</span><span class="p">(</span><span class="n">old_model</span><span class="p">)</span><span class="o">.</span><span class="n">total_params</span>
    <span class="n">params_new</span> <span class="o">=</span> <span class="n">summary</span><span class="p">(</span><span class="n">compressed_model</span><span class="p">)</span><span class="o">.</span><span class="n">total_params</span>
    <span class="nb">print</span><span class="p">((</span><span class="sa">f</span><span class="s1">&#39;Reduction by </span><span class="si">{</span><span class="n">params_old</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">params_new</span><span class="si">}</span><span class="s1"> parameters in the Input layer, resulting &#39;</span>
           <span class="sa">f</span><span class="s1">&#39;in a total model compression ratio of </span><span class="si">{</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">params_new</span><span class="o">/</span><span class="n">params_old</span><span class="p">)</span><span class="si">:</span><span class="s1">.1%</span><span class="si">}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">))</span>
    
    <span class="k">if</span> <span class="n">retrain</span> <span class="ow">and</span> <span class="n">retrain_params</span><span class="p">:</span>
        <span class="n">lr</span> <span class="o">=</span> <span class="n">retrain_params</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;lr&#39;</span><span class="p">,</span> <span class="mf">1e-4</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span> <span class="c1"># reduce learning rate for fine-tuning</span>
        <span class="n">patience</span> <span class="o">=</span> <span class="n">retrain_params</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;patience&#39;</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
        <span class="n">max_epochs</span> <span class="o">=</span> <span class="n">retrain_params</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;max_epochs&#39;</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
        <span class="n">stab</span> <span class="o">=</span> <span class="n">retrain_params</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;stabilizer&#39;</span><span class="p">,</span> <span class="mf">5e-3</span><span class="p">)</span>
        <span class="n">data_handle</span> <span class="o">=</span> <span class="n">retrain_params</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;data_handle&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">data_handle</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;No data_handle object provided for re-training the model!&#39;</span><span class="p">)</span>
        
        <span class="c1">## V1: fine-tuning the compressed model</span>
        <span class="n">train_loader</span><span class="p">,</span> <span class="n">val_loader</span> <span class="o">=</span> <span class="n">data_handle</span><span class="o">.</span><span class="n">give_torch_loader</span><span class="p">(</span><span class="n">window_size</span><span class="o">=</span><span class="n">new_window_size</span><span class="p">,</span>
                                                                 <span class="n">rnn_window</span><span class="o">=</span><span class="n">new_rnn_window</span><span class="p">,</span> <span class="n">keyword</span><span class="o">=</span><span class="s1">&#39;short&#39;</span><span class="p">)</span>
        <span class="n">opt</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">optim</span><span class="o">.</span><span class="n">Adam</span><span class="p">(</span><span class="n">compressed_model</span><span class="o">.</span><span class="n">parameters</span><span class="p">(),</span> <span class="n">lr</span><span class="o">=</span><span class="n">lr</span><span class="p">)</span>
        <span class="n">crit</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">MSELoss</span><span class="p">()</span> <span class="k">if</span> <span class="n">compressed_model</span><span class="o">.</span><span class="n">Pred_Type</span> <span class="o">==</span> <span class="s1">&#39;Point&#39;</span> <span class="k">else</span> <span class="n">GaussianNLLLoss</span><span class="p">()</span>
        <span class="nb">print</span><span class="p">((</span><span class="sa">f</span><span class="s1">&#39;Start fine-tuning the compressed model with lr=</span><span class="si">{</span><span class="n">lr</span><span class="si">:</span><span class="s1">.2e</span><span class="si">}</span><span class="s1">, patience=</span><span class="si">{</span><span class="n">patience</span><span class="si">}</span><span class="s1">, &#39;</span>
               <span class="sa">f</span><span class="s1">&#39;max_epochs=</span><span class="si">{</span><span class="n">max_epochs</span><span class="si">}</span><span class="s1"> and stab=</span><span class="si">{</span><span class="n">stab</span><span class="si">:</span><span class="s1">.2e</span><span class="si">}</span><span class="s1"> ...&#39;</span><span class="p">))</span>
        <span class="n">res_df</span> <span class="o">=</span> <span class="n">train_model</span><span class="p">(</span><span class="n">model</span><span class="o">=</span><span class="n">compressed_model</span><span class="p">,</span> <span class="n">train_loader</span><span class="o">=</span><span class="n">train_loader</span><span class="p">,</span> <span class="n">max_epochs</span><span class="o">=</span><span class="n">max_epochs</span><span class="p">,</span> <span class="n">optimizer</span><span class="o">=</span><span class="n">opt</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="s1">&#39;cpu&#39;</span><span class="p">,</span>
                        <span class="n">criterion</span><span class="o">=</span><span class="n">crit</span><span class="p">,</span> <span class="n">stabelizer</span><span class="o">=</span><span class="n">stab</span><span class="p">,</span> <span class="n">val_loader</span><span class="o">=</span><span class="n">val_loader</span><span class="p">,</span> <span class="n">patience</span><span class="o">=</span><span class="n">patience</span><span class="p">,</span> <span class="n">print_results</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Fine-tuning finished!</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">wrapped_model</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">compressed_model</span><span class="p">,</span> <span class="n">res_df</span><span class="p">,</span> <span class="n">init_params</span><span class="p">,</span> <span class="n">wrapped_init_params</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">compressed_model</span><span class="p">,</span> <span class="n">res_df</span><span class="p">,</span> <span class="n">init_params</span>
    
    <span class="k">if</span> <span class="n">wrapped_model</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">compressed_model</span><span class="p">,</span> <span class="n">init_params</span><span class="p">,</span> <span class="n">wrapped_init_params</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">compressed_model</span><span class="p">,</span> <span class="n">init_params</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright Bosch CR.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>